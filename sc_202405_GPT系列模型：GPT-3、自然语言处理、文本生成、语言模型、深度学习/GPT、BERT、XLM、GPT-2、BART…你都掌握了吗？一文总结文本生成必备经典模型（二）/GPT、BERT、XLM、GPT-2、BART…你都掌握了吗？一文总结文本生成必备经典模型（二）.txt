GPT、BERT、XLM、GPT-2、BART…你都掌握了吗？一文总结文本生成必备经典模型（二）
 机器之心专栏本专栏由机器之心SOTA！模型资源站出品，每周日于机器之心公众号持续更新。 本专栏将逐一盘点自然语言处理、计算机视觉等领域下的常见任务，并对在这些任务上取得过 SOTA 的经典模型逐一详解。前往 SOTA！模型资源站（sota.jiqizhixin.com）即可获取本文中包含的模型实现代码、预训练模型及 API 等资源。本文将分 2 期进行连载，共介绍 10 个在文本生成任务上曾取得 SOTA 的经典模型。第 1 期：Seq2Seq（RNN）、Seq2Seq（LSTM）、Seq2Seq+Attention、SeqGAN、Transformer第 2 期：GPT、BERT、XLM、GPT-2、BART您正在阅读的是其中的第 2 期。前往 SOTA！模型资源站（sota.jiqizhixin.com）即可获取本文中包含的模型实现代码、预训练模型及 API 等资源。第 1 期回顾：Seq2Seq、SeqGAN、Transformer…你都掌握了吗？一文总结文本生成必备经典模型（一）本期收录模型速览模型SOTA！模型资源站收录情况模型来源论文GPThttps://sota.jiqizhixin.com/project/gpt收录实现数量：2支持框架：TensorFlow、PyTorchImproving language understanding by generative pre-trainingBERT‍‍‍https://sota.jiqizhixin.com/project/bert-22收录实现数量：6支持框架：TensorFlowBERT: Pre-training of Deep Bidirectional Transformers for Language UnderstandingXLMhttps://sota.jiqizhixin.com/project/xlm收录实现数量：4支持框架：PyTorchCross-lingual Language Model PretrainingGPT-2https://sota.jiqizhixin.com/project/gpt-2收录实现数量：5支持框架：PyTorch、MindSpore、TensorFlowLanguage Models are Unsupervised Multitask LearnersBARThttps://sota.jiqizhixin.com/project/bart-8收录实现数量：1支持框架：PyTorchBART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension
文本生成（Neural Language Generation，NLG）是指从非语言的表示生成人类可以理解的文本。根据非语言表示的不同划分，文本生成包括“文本→文本”、“数据→文本”、“图像→文本”。随着深度学习、知识图谱等前沿技术的发展，基于图像生成文本描述的实验成果在不断被刷新。基于GAN的图像文本生成技术已经获得了非常好的效果，不仅能够根据图片生成非常好的描述，还能根据文本输出生成对应的图片。由数据生成文本，目前主要用于新闻撰写领域，中文和英文都有很大的进展。从应用任务的领域细分，机器翻译、对话系统（目标导向、开放式）、故事生成、诗歌生成、文本摘要等等都属于文本生成的范畴。与其他自然语言处理技术类似，文本生成也主要包括传统的文本生成方法（基于规则、基于统计）和基于神经网络的文本生成方法两类。


本文回顾文本生成领域必备的TOP模型，聚焦于“文本→文本”。所选出进行介绍的模型在提出之时，其目的可能是解决机器翻译、文本摘要、对话系统等不同的任务，因其经典性以及对文本生成整个领域中不同应用任务的巨大推动，我们都放入本文介绍。而针对具体的细分应用领域，例如机器翻译任务必备的TOP模型、文本摘要任务必备的TOP模型等等，我们将在具体的专题文章中详细介绍其中经典模型的改进历程。


 Improving language understanding by generative pre-training

GPT，也称为GPT-1，是OpenAI在论文《Improving Language Understanding by Generative Pre-Training》中提出的生成式预训练语言模型。该模型的核心思想：通过二段式的训练，第一个阶段是利用语言模型进行预训练（无监督形式），第二阶段通过 Fine-tuning 的模式解决下游任务（监督模式下）。GPT-1可以很好地完成若干下游任务，包括分类、蕴含、相似度、多选等。在多个下游任务中，微调后的GPT-1系列模型的性能均超过了当时针对特定任务训练的SOTA模型。GPT全称Generative Pre-Training，是一种半监督学习方法，具体方法是在针对有标签数据训练Fine-tune之前，用无标签数据预训练模型Pretrain，并保证两种训练具有同样的网络结构。GPT 采用两阶段过程，第一个阶段是利用语言模型进行预训练（无监督形式），第二阶段通过 Fine-tuning 的模式解决下游任务（监督模式下）。模型的结构如图1。
图1. （左）本工作中使用的transformer结构和训练目标。(右）在不同任务上进行微调的输入转换。将所有的结构化输入转换为标记序列，由预训练模型处理，然后是线性+softmax层
GPT-1由12层Transformer Decoder的变体组成，称其为变体，是因为与原始的Transformer Decoder相比，GPT-1所用的结构删除了Encoder-Decoder Attention层，只保留了Masked Multi-Head Attention 层和Feed Forward层，并扩大了网络的规模。将层数扩展到12层，GPT-1还将Attention 的维数扩大到768（原来为512），将Attention的头数增加到12层（原来为8层），将Feed Forward层的隐层维数增加到3072（原来为2048），总参数达到1.5亿。GPT-1还优化了学习率预热算法，使用更大的BPE码表，将ReLU改为对梯度更新更友好的高斯误差线性单元GeLU，将正余弦构造的位置编码改为了带学习的位置编码。非监督预训练在预训练部分，用u表示每一个token(词)，当设置窗口长度为k，预测句中的第i个词时，则使用第i个词之前的k个词，同时也根据超参数Θ，来预测第i个词最可能是什么。简言之，用前面的词预测后面的词。


具体方法是代入Transformer模型，下式中的模型由l组（block）隐藏层组成，最初输入隐藏层的数据是词编码U乘词嵌入参数We加上位置参数Wp；后面经过l个层处理：


监督微调接下来是要对前一个阶段训练出来的模型参数进行微调，以适应当前的监督型任务。假设有带标签的数据集C，数据结构为(x_1,x_2,…,x_m,y)，然后输入(x_1,x_2,…,x_m)，经过预训练模型在输入上的迭代之后，获得输出向量h_m^l，然后经过线性层和softmax得到预测标签：


W_y 表示预测输出时的参数，微调时候需要最大化以下函数：


GPT 在微调的时候也考虑预训练的损失函数，所以最终需要优化的函数为：



当前 SOTA！平台收录 GPT 共 2 个模型实现资源，支持的主流框架包含 TensorFlow、PyTorch 等。

项目SOTA！平台项目详情页GPT前往 SOTA！模型平台获取实现资源：https://sota.jiqizhixin.com/project/gpt

 BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding

BERT（Bidirectional Encoder Representations from Transformers）自从谷歌提出就一直大热，很多人认为Bert是整个NLP研究历程中里程碑似的节点。BERT的灵感来源是“Attention is all your need”中提到的Transformer模型。Bert用transformer的双向编码器表示。BERT通过在所有层的上下文联合调节来预训练深度双向表示。因此，预训练的bert可以添加一个额外的输出层进行微调，可以在广泛的任务上产生目前最好的效果。例如问答和语言推理，不需要大量特定任务的结构的修改。此外，bert受到完形填空的启发，通过 “masked language model” (MLM)预训练目标来缓解前面提到的单向性约束。masked语言模型从输入中随机掩码一些符号，并且目标是仅仅基于上下文来预测掩码词的原始词汇id。不同于left-to-right模型的预训练，MLM目标使得表示能够融合上下文，从而预训练一个深层的双向transformer。除了掩码语言模型，BERT还使用“下一句话预测”任务，联合预训练文本对表示。BERT的网络结构使用了双向Transformer的堆叠，Encoder和Decoder分别12层。BERT加入了Masked Language Model(MLM) 和 Next Sentences Prediction(NSP），使得模型能够在无监督的场景下学习到句子间特征和语义特征。在无监督学习场景训练，能最大化的使用训练语料。而Pre-train和Fine-tune能够方便地将已训练好的BERT模型迁移到不同的应用场景，在工业界大有益处。下图为Bert的输入图示。由图示可知，Bert的输入包括三个部分：词嵌入张量（Token embeddings）、语句分块张量（ segmentation embeddings）、位置编码张量（position embeddings），最终的embedding向量是将上述的3个向量直接做加和的结果。
图2. BERT输入表示。输入嵌入是标记嵌入、分割嵌入和位置嵌入的总和。嵌入和位置嵌入的总和
接下来，MLM和 NSP是Bert的另外两个亮点：Bert中引入了一个带mask的语言模型训练（Masked LM）。为了训练深度双向的表示，随机mask一定百分比的输入token，然后去预测那些掩码处理掉的token。作者将这个过程称为是“masked LM”（MLM），它在文献中通常被称为完形填空任务。在这种情况下，对应于mask token的最终的隐藏向量通过词汇表输出softmax，如标准的LM。 具体而言，在原始训练文本中，随机抽取15%的token作为即将参与mask的对象。在选中的token中，数据生成器并不是把他们全部变成[MASK]，具体变化方法包括三类：一是，在80%的概率下，用[MASK]标记替换token，比如my dog is hairy → my dog is [MASK]；二是，在10%的概率下，用随机单词替换token，比如my dog is hairy → my dog is apple；三是，在10%的概率下，保持token不变，比如my dog is hairy → my dog is hairy。Bert还引入了一个下一句话预测任务（Next Sentence Prediction ）。许多重要的下游任务，例如问答（QA）和自然语言推理，都是基于理解两个句子之间的关系，而不是由语言建模直接捕获的。为了训练理解句子关系的模型，作者预训练了二进制的下一句预测任务，该任务可以从任何单语语料库中轻松的生成。具体而言，所有的参与任务训练的语句都被选中参加，其中：50%的B是原始本中实际跟随A的下句话；50%的B是原始本中随机抽取的一句话。在该任务中，Bert模型可以在测试集上取得97-98%的准确率。最后，fine-tuning是Bert的另一个亮点，只需要将特定任务的输入输出插入到Bert中，利用Transformer强大的注意力机制就可以模拟很多下游任务，从而具有极佳的迁移特性。

当前 SOTA！平台收录 BERT 共 6 个模型实现资源，支持的主流框架包含 TensorFlow 等。

项目SOTA！平台项目详情页BERT‍‍‍前往 SOTA！模型平台获取实现资源：https://sota.jiqizhixin.com/project/bert-22

Cross-lingual Language Model Pretraining  

BERT模型可以在上百种语言上进行预训练，语言之间的信息并不是互通的，不同的语言模型之间没有共享知识。Facebook的XLM模型克服了信息不互通的难题，它将不同语言放在一起采用新的训练目标进行训练，从而让模型能够掌握更多的跨语言信息。这种跨语言模型的一个显著优点是，对于预训练后的后续任务（比如文本分类或者翻译等任务），训练语料较为稀少的语言可以利用在其他语料上学习到的信息。XLM模型训练有两种方法：一种是只依靠单语数据的无监督方法，另一种是利用平行数据与跨语言模型的有监督方法。通过XLM，可以将任何句子编码到一个共享的embedding空间。XLM的三个重要组成部分：CLM（Causal Language Modeling）、MLM（Masked Language Modeling）和TLM（Translation Language Modeling ）。前两个使用的是单语数据monolingual data（无监督学习）；后一个使用的是平行语料（parallel sentences）也就是需要通过监督的方式学习。考虑N种语言的情况，假设有N个单语语料库{C_i}_i=1...N，使用n_i表示C_i中的句子数量。 Shared sub-word vocabulary XLM通过字节对编码（ Byte Pair Encoding，BPE）创建的同一套共享词汇来处理所有语言，这极大地改善了不同语言的嵌入空间的一致性，这些语言共享相同的字母或锚定标记，如数字或专有名词。在从单语语料库中随机抽取的句子的连接上学习BPE分词。句子的抽样根据概率为{q_i}_i=1...N的分布进行抽样，其中q_i表示为：


Causal Language Modeling (CLM)
因果语言建模（Causal Language Modeling，CLM）任务由一个Transformer语言模型组成，该模型经过训练，可以根据句子中的前几个词来模拟一个词的概率P(w_t|w_1, ... , w_t-1, θ)。 Masked Language Modeling (MLM) 掩码语言建模masked language modeling (MLM）任务从文本流中随机抽取15%的BPE标记，80%用[MASK]标记替换，10%用随机标记替换，10%保持不动。

图3. 跨语言的语言模型预训练。

TLM目标将MLM扩展到平行句子对。为了预测一个被掩码的英语单词，该模型可以同时关注英语句子和它的法语翻译，并鼓励将英语和法语的表征对齐。重置目标句子的位置嵌入，以促进对齐 Translation Language Modeling (TLM) CLM和MLM的目标函数都是无监督的，只需要单语数据。当平行数据可用时，进一步引入了一个新的翻译语言建模（ translation language modeling ，TLM）目标函数来改进跨语言的预训练。TLM的目标函数是对MLM的扩展，不考虑单语文本流，而是将平行的句子连接起来。在源句和目标句中随机掩码处理单词。为了预测英语句子中被掩码的单词，该模型既可以关注临近的英语单词，也可以关注法语翻译，鼓励该模型将英语和法语的表述统一起来。特别是，如果英语上下文不足以推断出被掩码的英语单词时，该模型还可以利用法语上下文。为了促进对齐，重新设定了目标句子的位置。 Cross-lingual Language Models 考虑对XLMs（CLM、MLM或TLM）进行跨语言模型预训练：对于CLM和MLM的目标函数，使用由256个标记组成的64个连续句子流来训练模型。在每次迭代中，利用来自同一语言的句子组成一个batch，从上述分布{q_i}_i=1...N中取样，设定公式中α=0.7。当TLM与MLM结合使用时，在这两个目标函数之间交替执行预训练，并以类似的方法对语言进行抽样。

当前 SOTA！平台收录 XLM 共 4 个模型实现资源，支持的主流框架包含 PyTorch 等。

项目SOTA！平台项目详情页XLM前往 SOTA！模型平台获取实现资源：https://sota.jiqizhixin.com/project/xlm

Language Models are Unsupervised Multitask Learners

自然语言处理任务，如问题回答、机器翻译、阅读理解和总结，通常在特定任务的数据集上进行监督学习。作者证明，当在一个名为WebText的数百万网页的新数据集上训练时，语言模型能够在没有任何明确监督的情况下学习这些任务。该数据集做了一些简单的数据清理，并且覆盖领域十分广阔。语言模型的容量对zero-shot任务迁移的成功至关重要，增加它可以在不同的任务中以对数线性的方式提高性能。本文提出的最大的模型，GPT-2，是一个1.5B参数的Transformer，在zero-shot的情况下，在8个测试的语言建模数据集中的7个取得了最先进的结果。GPT-2是GPT的升级版本，其最大的区别在于规模更多，训练数据更多，GPT是12层的transformer，BERT最深24层transformer，GPT-2则是48层，共有15亿个参数。其次，相比于BERT，GPT-2没有采用双向的transformer，依旧采用单向transformer。再次，在预训练阶段，GPT-2采用了多任务的方式，每一个任务都要保证其损失函数能收敛，不同的任务是共享主体transformer参数的，这样能进一步的提升模型的泛化能力，因此在没有fine-turning的情况下依旧有非常不错的表现。综上，GPT-2的特点就是：多任务预训练+超大数据集+超大规模模型。语言建模通常是由一组数据构成的无监督分布估计，每一条数据都是可变长度的符号序列组成，由于语言具有自然的顺序排列，因此通常将符号上的联合概率分解为条件概率的乘积：

学习某项单一的任务可以用概率学中的条件概率 p(output|input)来表示。对于一般的系统应该能执行许多不同的任务，即使是对于同样的输入，也不仅仅只对输入有要求，对待执行的任务也要有一定的要求。因此模型应该是 p(output|input,task)。这已经在多任务和元学习中得到了不同的体现。一个通用的语言模型（ language model ，LM）应该能够计算出任何字符串的概率（也能生成）。目前的大规模语言模型包括预处理步骤，如小写字母、标记化和词汇外标记，这些步骤限制了可建模字符串的空间。虽然将Unicode字符串作为UTF-8字节序列进行处理可以很好地满足这一要求，但目前的字节级LM在大规模数据集上与单词级LM相比没有竞争力。字节对编码（ Byte Pair Encoding ，BPE）是字符和字级语言建模之间的一个实用的中间地带，它在频繁的符号序列的字级输入和不频繁的符号序列的字符级输入之间进行有效插值。尽管它的名字叫BPE，但参考的BPE实现通常是在Unicode代码点而不是字节序列上操作的。这些实现需要包括Unicode符号的全部空间，以便对所有Unicode字符串进行建模。这将导致在添加任何多符号标记之前，基础词汇量超过130,000。与BPE经常使用的32,000到64,000个符号词汇相比，这个数字大得惊人。相比之下，BPE的字节级版本只需要256大小的基础词汇。然而，直接将BPE应用于字节序列会导致次优的合并，这是因为BPE使用了一种贪婪的基于频率的启发式方法来建立token词汇表。作者观察到BPE包括了许多像狗这样的常用词的版本，因为它们出现了许多变体，如狗...狗！狗？这导致了对有限的 vocabulary slots 和模型容量的次优分配。为了避免这种情况，作者阻止BPE对任何字节序列进行跨字符类别的合并。作者为空格增加了一个例外，这大大地提高了压缩效率，同时只在多个词汇token之间增加了最小的单词碎片。这种输入表示法使我们能够将词级LM的经验优势与字节级方法的通用性结合起来。由于该方法可以给任何Unicode字符串分配一个概率，这使得我们可以在任何数据集上评估LM，而不考虑预处理、 tokenization 或词汇量。本文语言模型内部采用的是transformer结构，该模型在很大程度上遵循OpenAI GPT模型的细节，只是做了一些修改。首先每一个sub-block的输入的layer normalization被移除了，类似于一个预激活的残差网络，并在最后的self-attention模块中添加了layer normalization。采用修正的初始化方法，考虑了模型深度对当前层的影响，在初始化权重时将剩余层的权值乘以1/sqrt{N}，其中N是残缺层的数量，词典被扩展到了50257，context的维度从512提高到了1024，并且batchsize为512。
当前 SOTA！平台收录 GPT-2 共 5 个模型实现资源，支持的主流框架包含 PyTorch、TensorFlow 等。

项目SOTA！平台项目详情页GPT-2前往 SOTA！模型平台获取实现资源：https://sota.jiqizhixin.com/project/gpt-2


BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension 

BART（Bidirectional and Auto-Regressive Transformers）基本是标准的sequence to sequence形式的transformer，只不过其中的激活函数换成了gelu。BART是encoder-decoder的结构，其encoder端的输入是加了噪音的序列，decoder端的输入是右移的序列，decoder端的目标是原序列。首先，我们先对最经典的BERT、GPT及BART进行对比：
GPT：是一种 Auto-Regressive(自回归)的语言模型。它也可以看作是Transformer model的Decoder部分，它的优化目标就是标准的语言模型目标：序列中所有token的联合概率。GPT采用的是自然序列中的从左到右（或者从右到左）的因式分解。BERT：是一种Auto-Encoding(自编码)的语言模型。它也可以看作是Transformer model的Encoder部分，在输入端随机使用一种特殊的[MASK]token来替换序列中的token，这也可以看作是一种noise，所以BERT也叫Masked Language Model。BART：吸收了 BERT 的 bidirectional encoder 和 GPT 的 left-to-right decoder 各自的特点；建立在标准的 seq2seq Transformer model 的基础之上，这使得它比 BERT 更适合文本生成的场景；此外，相比GPT也多了双向上下文信息。在生成任务上获得进步的同时，它也可以在一些文本理解类任务上取得SOTA。


图4. Bert、GPT、Bart对比
如图4，Bart是一个BERT+GPT的结构，不同之处在于相对于BERT中单一的noise类型(只有简单地用[MASK] token进行替换这一种noise)，BART在encoder端尝试了多种噪声。其原因和目的也很简单：BERT的这种简单替换导致的是encoder端的输入携带了有关序列结构的一些信息（比如序列的长度等信息），而这些信息在文本生成任务中一般是不会提供给模型的；而BART采用更加多样的noise，目的是破坏掉这些有关序列结构的信息，防止模型去“依赖”这样的信息。具体的预训练任务如下：

图5. 对实验输入进行噪声变换
其中：Token Masking与bert相同。Token Deletion删除token，与Token Masking不同的是模型还要预测在哪个位置删除的。Text Infilling填充文字，缺失的文字片段，片段的长度服从泊松分布，每个文字也是mask的形式。Sentence Permutation句子排列， 根据标点把句子顺序打乱，使其还原。Document Rotation随机选取一个文本让其与其之后的移到最前面，然后让模型去确定哪个句子是最开始的。

当前 SOTA！平台收录 BART 共 1 个模型实现资源，支持的主流框架包含 PyTorch 等。

项目SOTA！平台项目详情页BART前往 SOTA！模型平台获取实现资源：https://sota.jiqizhixin.com/project/bart-8
前往 SOTA！模型资源站（sota.jiqizhixin.com）即可获取本文中包含的模型实现代码、预训练模型及API等资源。 网页端访问：在浏览器地址栏输入新版站点地址 sota.jiqizhixin.com ，即可前往「SOTA！模型」平台，查看关注的模型是否有新资源收录。 移动端访问：在微信移动端中搜索服务号名称「机器之心SOTA模型」或 ID 「sotaai」，关注 SOTA！模型服务号，即可通过服务号底部菜单栏使用平台功能，更有最新AI技术、开发资源及社区动态定期推送。

