
            <!DOCTYPE html>
            <html lang="zh-CN">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta name="description" content="本文按照时间顺序整理了大语言模型发展过程，对比不同模型的结构，阐述了模型的训练过程。">
                <meta name="keywords" content="生成式AI与LLM模型的演变, 本文按照时间顺序整理了大语言模型发展过程，对比不同模型的结构，阐述了模型的训练过程。">
                <meta property="og:title" content="生成式AI与LLM模型的演变">
                <title>生成式AI与LLM模型的演变</title>
                <style>.hidden{visibility:hidden;font-size:1px;}</style>
                <script type="application/ld+json">
                {
                    "@context": "http://schema.org",
                    "@type": "WebPage",
                    "name": "生成式AI与LLM模型的演变",
                    "description": "本文按照时间顺序整理了大语言模型发展过程，对比不同模型的结构，阐述了模型的训练过程。",
                    "code": "/s?__biz=MzkwODY1MzAyMQ==&mid=2247483699&idx=1&sn=021a0ba7f24a805de863584ff8b8c054&chksm=c0c7f981f7b070972e495fbb5711e6cf725c6fddb25231db62d13130e2a2ce47726ab9139497#rd"
                }
                </script>
            </head>
            <body>
                <div class="rich_media_wrp" id="img-content">
<h1 class="rich_media_title" id="activity-name">
            
生成式AI与LLM模型的演变
          </h1>

<div class="rich_media_content js_underline_content autoTypeSetting24psection" id="js_content" style="visibility: visible;"><section style="text-align: justify;margin-bottom: 24px;"><span style="font-size: 18px;"><strong>前言</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000021" data-ratio="0.48518518518518516" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlDQK7AVtVPPLXolMW1kgGPp8ukxOgRsyg02GOXM4qXnicLjib4nV7kXQw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000719_0.jpeg" style="letter-spacing: 0.578px;white-space: normal;width: 578px;" title="生成式AI与LLM模型的演变"/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="font-size: 16px;">谈及大型语言模型，我们自然而然地联想到了22年十一月由OpenAI发布的ChatGPT，这款模型上线仅仅两个月就迅速吸引了一亿用户，在业界掀起了巨大的轰动。ChatGPT展现出了惊人的理解力和创造性，使其具有一种近乎人类的情感，更彷佛是艺术作品中的人工智能，为技术发展揭示了全新的道路。这一模型验证了一条崭新的技术路线，是OpenAI在2018年开始不断迭代的引人注目的成果。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 16px;">2018年6月，OpenAI提出了GPT，这是他们首次将预训练+微调的范式应用到自然语言处理（NLP）中，并采用了基于Transformer的架构。这种架构能够捕捉到文本中的长距离依赖关系，从而提高了模型的理解能力。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 16px;">在后续的GPT-2中，OpenAI提出了零样本学习（Zero-shot）的设定，并将模型规模进一步扩大。零样本学习是指模型在没有看到任何目标任务样本的情况下，仅通过训练数据就能完成任务，这可以让模型能够更好地泛化到未见过的任务上。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 16px;">在GPT-3中，OpenAI提出了少样本学习（Few-shot）的设定，并发现随着模型规模的增大，会出现一些新的能力。同时，GPT-3也展示出上下文学习（In-context learning）的能力，即模型能够根据前文的信息来生成后文。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 16px;">在Instruct-GPT中，OpenAI首次使用了基于人类反馈的强化学习（RLHF）的方法，将这种大型语言模型与人类价值观进行对齐，使模型能够更好地理解人类的意图。这种方法通过人类的反馈来指导模型的行为，使其能够更好地满足人类的需求。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 16px;">到现在的GPT-4，它已经成为了一种多模态的大型语言模型。多模态是指模型能够处理多种类型的输入，如文本、图像等。这使得模型能够更好地理解和生成包含多种信息的内容，从而进一步提高了模型的应用范围和效果。总的来说，从GPT1到GPT-4，我们可以看到OpenAI在大型语言模型方面的持续探索和进步。这些模型不仅在技术上取得了突破，也在实际应用中取得了显著的效果，为人工智能的发展开辟了新的道路。</span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><br/></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 24px;'><span style="font-size: 18px;"><strong>GPT-1(2018.06)</strong></span></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="font-size: 16px;">在自然语言处理（NLP）领域，存在着大量未标记的文本，与图像领域不同，缺乏像ImageNet这样经过精心标注的数据集。因此，在这个背景下，当时广泛采用的方法之一是无监督预训练，并在后续的下游任务中进行微调。GPT一文的创新之处在于首次将Transformer架构引入到这种预训练和微调的模式中。</span></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="letter-spacing: 0.578px;font-size: 16px;">与以往的LSTM相比，Transformer采用了自注意力机制(self-attention)，从而解决了长距离依赖问题，并且能够更有效地进行并行计算。特别是随着模型规模的增大，Transformer结构在性能上明显优于LSTM结构。GPT的独特之处在于它仅使用了Transformer结构中的解码器部分，这种设计决策为模型的成功应用奠定了基础。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000015" data-ratio="0.6954887218045113" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlcdO8XQSbX7DLky9MiczfFO9RBL0tGkMUpkVyFlCtHIP5QbvjRHyZS0g/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="798" src="20240527_000722_1.jpeg" style="width: 511px;height: 355px;" title="生成式AI与LLM模型的演变"/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><br/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="font-size: 16px;">首先，我们来考察预训练阶段。在这个阶段，训练的目标是根据已知的k个token，预测第k+1个token，本质上是在进行文本补全的任务。以句子层面来看，这就是在给定一些不完整的句子的情况下进行补全。与最初的Transformer相似，首先进行词嵌入和位置嵌入，然后通过n个Transformer块的处理，最终经过softmax计算，使输出的概率达到最大。这个过程实质上是在通过模型学习文本结构和语境，使其能够有效地理解并预测文本中缺失的部分。</span></section><section style="margin-top: 0px;text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000010" data-ratio="0.5701311806256307" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlhHdvxsVy9TQThpEPq2wgQ0yH9MybRKrg81Jib8tmmFdX3YQ2GRCticSA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="991" src="20240527_000724_2.jpeg" style="letter-spacing: 0.578px;text-align: center;white-space: normal;width: 512px;height: 292px;" title="生成式AI与LLM模型的演变"/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="font-size: 16px;">损失计算方式：<br/></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000011" data-ratio="0.3635346756152125" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDllicFU9fulJ98uyTh1G10JT1wibrmc4u41kowbRUfdk4ssOyIfyDfymOw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="894" src="20240527_000726_3.jpeg" style="width: 515px;height: 187px;" title="生成式AI与LLM模型的演变"/></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000013" data-ratio="0.2580195258019526" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDl5mInYKt1yF01cSfeSgNE7h1ndXmmX27ricEutK9CnY2MhERhSXpONyA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="717" src="20240527_000728_4.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">第二阶段涉及到对下游任务进行有监督微调。当时主要的NLP任务包括分类、蕴涵、相似性以及多项选择。针对每一项任务，重新设计了输入数据的格式，在输入中引入了特殊的标记，并添加了可训练的线性层。具体而言，对于分类任务，在文本前后加入起始(start)与结束(Extract)标志符，经过Transformer模块与一个线性层得到分类结果；对于蕴含任务（文本间的推理关系，如问题-&gt;答案），将所需判断的两段文本通过中间符号(Delim)进行拼接，拼接文本的前后加入起始结束标志符，经过线性层和softmax即可；对于相似度任务，由于需要考虑两个句子的顺序，因此作者对两个句子分别拼接，加上特殊标志符后经过Transformer得到两个向量，相加后经过线性层和softmax；对于多项选择问题，作者将问题与候选答案进行拼接，计算哪种形式的概率最大，相当于多分类任务。</span></section><p style="text-align: center;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000050" data-ratio="0.5009259259259259" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQDAEpRImu4eaDbaXRD1LQTGzvCf4zprDUnCp9iaGiaFDL3DlgdUympTHA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000732_5.jpeg" style="" title="生成式AI与LLM模型的演变"/></p><section style="margin-bottom: 24px;"><span style="font-size: 16px;">这里的Transformer依然是第一阶段预训练模型，但其权重被冻结，不再进行更新。<span style="letter-spacing: 0.578px;">上述起始、结束与中间分割符标志虽然在预训练中不曾出现过，但因为第二阶段linear层的训练，模型依旧能学习到这几种特殊标志符。</span>在目标函数中，还包括了一项预训练阶段的目标函数，这有助于赋予模型更强的泛化性，减缓灾难性遗忘问题的发生。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">通过这一微调阶段，模型得以专门适应不同的NLP任务，通过任务特定的头部结构和调整，使得模型在完成这些任务时能够更加有效地捕捉关键信息。同时，引入预训练目标函数的权重，为模型提供了一种迁移学习的机制，使其在新任务上表现更加鲁棒和具有广泛适应性。预训练+微调训练框架为GPT模型在各种NLP任务上的出色性能奠定了坚实的基础。</span></section><section style="margin-bottom: 24px;"><br/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><span style="font-size: 18px;"><strong>Bert(2018.10)</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100000020" data-ratio="1.524390243902439" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlFA8rqSc0HNOky975mr7N9ofiazvMdia601U8pn5I1100fX36rY5wRbdw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="492" src="20240527_000734_6.jpeg" style="width: 283px;height: 431px;" title="生成式AI与LLM模型的演变"/></section><section style="margin-top: 0px;text-align: justify;margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">在OpenAI发布GPT-1后不久，Google推出了BERT。与GPT相似，BERT同样采用了预训练加微调的范式，但其结构是Transformer中的编码器，被称为encoder-only。与decoder-only相比，BERT使用了双向注意力机制。因此，在BERT的预训练阶段，任务不再是根据前面的标记来预测下一个标记。相反，BERT的预训练包含两个任务：一是遮掩句子中的部分词，让模型在上下文的帮助下预测被遮掩的词；二是判断两个句子是否是相邻的两个句子。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000022" data-ratio="0.595166163141994" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlyoicTpPqlBn7uqzcT5iaYTqzn9iaIF9wxicTaVcvuDvtibWj1cfEozchLgA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="993" src="20240527_000737_7.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">在第一个任务中，BERT通过遮蔽一些词语，促使模型学会通过上下文的语境来推断被遮蔽的词，从而提升了模型对文本的理解能力。而第二个任务则使BERT在预训练过程中学会处理两个句子之间的关联性，可以让模型更好地理解句子之间的语义关系。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">这种encoder-only结构和双向注意力机制的设计，使BERT在捕捉句子中的全局信息和关系时表现出色。BERT的发布不仅推动了NLP领域的发展，也引领了预训练模型的新潮流，为自然语言处理任务带来了重大的创新。<strong style="font-size: var(--articleFontsize);letter-spacing: 0.034em;"></strong></span></section><section style="margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>Bert vs GPT</strong></span></section><section style='margin-top: 12px;user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><span style="font-size: 16px;"><span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">BERT</span>和<span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">GPT</span>是两种具有代表性的大型预训练语言模型，它们在结构和训练任务上有显著的不同。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000023" data-ratio="0.23148148148148148" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDl5nnvQCPNVVsDE9b16Bia3LeX89AY5FbvBzCG1wu1tYsjF5B4bW9l1IQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000739_8.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><ol class="list-paddingleft-1" style='margin-top: 12px;display: flex;flex-direction: column;gap: 4px;padding-inline-start: 24px;color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;font-size: 16px;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);'><li style="font-size: 16px;"><section style="margin-bottom: 24px;"><section style="user-select: text;word-break: break-word;font-size: var(--cib-type-body2-font-size);line-height: var(--cib-type-body2-line-height);font-weight: var(--cib-type-body2-font-weight);font-variation-settings: var(--cib-type-body2-font-variation-settings);display: inline;margin-bottom: 8px;"><span style="font-size: 16px;"><span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">结构和训练任务</span>：BERT采用了<span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">encoder-only</span>的结构，预训练任务是<span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">完形填空</span>。这种结构可以同时考虑上下文的两个方向，因此能更好地捕捉上下文信息，适合自然语言理解（NLU）任务，也就是理解型的任务。而GPT采用了<span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">decoder-only</span>的结构，预训练任务是<span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">预测下一个token</span>。这种结构适合没有限制的生成任务，比如文本生成。</span></section></section></li><li style="font-size: 16px;"><section style="margin-bottom: 24px;"><section style="user-select: text;word-break: break-word;font-size: var(--cib-type-body2-font-size);line-height: var(--cib-type-body2-line-height);font-weight: var(--cib-type-body2-font-weight);font-variation-settings: var(--cib-type-body2-font-variation-settings);display: inline;margin-bottom: 8px;"><span style="font-size: 16px;"><span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">训练数据</span>：BERT的训练数据量比GPT多了几倍。这可能是BERT在相同参数量下效果更好的一个原因。</span></section></section></li><li style="font-size: 16px;"><section style="margin-bottom: 24px;"><section style="user-select: text;word-break: break-word;font-size: var(--cib-type-body2-font-size);line-height: var(--cib-type-body2-line-height);font-weight: var(--cib-type-body2-font-weight);font-variation-settings: var(--cib-type-body2-font-variation-settings);display: inline;margin-bottom: 8px;"><span style="font-size: 16px;"><span style="line-height: var(--cib-type-subtitle2-stronger-line-height);font-weight: var(--cib-type-subtitle2-stronger-font-weight);font-variation-settings: var(--cib-type-subtitle2-stronger-font-variation-settings);">模型规模</span>：BERT还将模型做得更大，从而提升了模型的效果。这是因为模型规模的增大可以提高模型的容量，使其能够学习更多的模式和知识。</span></section></section></li></ol><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000024" data-ratio="0.20833333333333334" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDl28uevicXZro9ltzpKiaa7YurZuqRFbPVZ4nyzCvFRib6GYvAsysLlIdicg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000741_9.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">Base级别的Bert模型对标GPT-1，通过上面表格可以看出即使在模型大小差不多的情况下，Bert的效果依旧很好，因此openAI继续沿着自己的思路不断叠加模型参数与数据量，在后面发布了GPT-2。</span></section><section style="margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 18px;"><strong>GPT-2(2019.08)</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000025" data-ratio="0.45925925925925926" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlQjqvq6W6ogpqC7BaXXF3eqEqO66rykicNZR3XszLVECPSPDYCAcUoSg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000744_10.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;"><span style="letter-spacing: 0.578px;">相比于在模型结构上的改变，GPT-2更多的是</span>在训练数据上进行了扩充，将词表进行扩充，并且将layer norm放在每个transformer块的输入端。这里的主要贡献是提出了一种新的设定，语言模型在zero-shot的设置下可以完成一些下游任务，而且语言模型的容量是实现zero-shot任务迁移的关键。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">Zero-shot learning指的是模型可以识别出在训练阶段没有见过的类别。这里的零样本学习指的是在推理阶段，与训练过程的少样本学习不同。训练阶段的少样本学习指的是只在少量样本上进行训练，研究的是模型的鲁棒性和泛化能力，而<span style="letter-spacing: 0.034em;">这里的零样本学习和下面提到的</span>少<span style="letter-spacing: 0.034em;">样本学习不涉及到模型参数的更新。比较这种方式和迁移学习的区别，迁移学习指的是训练好一个预训练模型，针对不同的下游任务去做微调，比如下面图片中的情感分类和新闻分类任务，针对不同的任务设计输入格式微调，之后输出对应的类别；而zero-shot learning指的是直接使用预训练好的模型。但是在推理阶段，也就是在使用的时候需要根据不同的任务设计template。比如这里的分类任务，template可以设计为文本与它标签的组合，让模型输出是否就好了，而在迁移学习中是直接输出标签；在这种设定下，GPT-2在多种任务上取得了不错的成绩。</span></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000026" data-ratio="0.3709677419354839" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDl6mupwI6aKuR3UpDkB5Nm1Ykq8fp05ia1HKKC5ckOUD3sSBGn8k0S2lg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="992" src="20240527_000746_11.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000027" data-ratio="0.39014373716632444" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlB0NHiaciabyFX6YiaKkeXNAJFsIRCIosh545WC1KttdC6Rkic9XmXasFvA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="974" src="20240527_000747_12.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="letter-spacing: 0.034em;font-size: 16px;">比较有意思的是，在perplexity曲线上，train和test一直是下降的趋势，所以GPT-2在这个数据集上仍然是underfit的状态，这也是openAI继续将模型扩大的原因之一。（perplexity用于衡量语言模型质量，反应模型能够正确预测测试集中的每个词的困难程度。）</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000028" data-ratio="0.8853410740203193" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7Lia0ah0JXX6or6aT8J8iaaXDlUoNvx7sTrM51cVZZKL69eLLhPJ0sCWicIjlhBsnXzstJGs8eJ6ufblw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="689" src="20240527_000749_13.jpeg" style="width: 464px;height: 411px;" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 18px;"><strong>GPT-3(2020.05)</strong></span></section><section style='user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><span style="font-size: 16px;">GPT-3是OpenAI的一款自然语言处理模型，它的大小从GPT-2的1.5B扩增到了175B，模型依旧采用decoder-only的结构。这个模型参数量的巨大跨越不仅提高了模型的性能，也使得模型能够更好地理解和生成人类语言。同时，GPT-3提出了一种新的学习设定，即few-shot learning。这种设定的提出，主要是为了解决两个问题。</span></section><section style='margin-top: 12px;user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><span style="font-size: 16px;">首先，随着模型规模的不断增大，针对不同的下游任务去修改模型参数对显卡的要求非常高。这是因为模型的参数数量增加，需要更大的显存来存储这些参数，同时也需要更强的计算能力来进行参数的更新。对于一个模型来说，微调需要考虑的显存占用因素主要有：模型权重（4bytes*模型参数量）、反向传播梯度（<span style='color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;background-color: rgb(255, 255, 255);'>4bytes*模型参数量</span>）、优化器状态（8<span style='color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;background-color: rgb(255, 255, 255);'>bytes*模型参数量，对于Adam优化器而言</span>）、前向激活值（主要和序列长度、隐藏维度、批次大小有关）。如果对每一个下游任务都进行模型参数的修改，那么这将对硬件设备提出极高的要求，这对于大多数用户来说是不可接受的。</span></section><section style='margin-top: 12px;user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><span style="font-size: 16px;">其次，对于人类而言，我们需要的是能够直接回答我们问题的模型，因此最理想的状态是使用zero shot来完成下游任务，也就是只通过instruction+answer的形式来让模型理解并完成任务，而且我们需要一个all-in-one的模型来解决所有下游任务。然而，实际情况是，即使是模型参数量很高的预训练模型，比如GPT-3，也并不能很好地理解这种形式的指令。但是，研究人员发现，如果在指令之前提供几个示例，那么模型的理解和生成能力会有显著的提高。因此，大家都开始研究few-shot prompting技术。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000029" data-ratio="0.6277495769881557" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQMQyjKibp9ibutlmhCnYI5O2aInXaKjXzic4CPNG71UuFiawNEzB7oEZAMg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="591" src="20240527_000751_14.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style='margin-top: 12px;user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><span style="font-size: 16px;">我们需要明白，few-shot prompting技术实际上也是一种折衷的方法。它既没有达到zero shot的理想状态，也没有解决模型规模增大带来的硬件要求。但是，它至少在一定程度上解决了这两个问题，使得模型能够更好地完成下游任务。</span></section><section style='margin-top: 12px;user-select: text;word-break: break-word;font-size: 16px;line-height: var(--cib-type-body2-line-height);font-variation-settings: var(--cib-type-body2-font-variation-settings);color: rgb(17, 17, 17);font-family: -apple-system, Roboto, SegoeUI, "Segoe UI", "Helvetica Neue", Helvetica, "Microsoft YaHei", "Meiryo UI", Meiryo, "Arial Unicode MS", sans-serif;letter-spacing: normal;text-align: start;white-space: normal;background-color: rgb(255, 255, 255);margin-bottom: 24px;'><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 18px;"><strong>Instruct-GPT(2022</strong></span><span style="font-size: 18px;"><strong>.01</strong><strong>)</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000033" data-ratio="0.5935185185185186" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQPGR2DhKeJYsCpOAOnmB3Udwh83xWdh9vBEphzrYRApjPvIibEt9CgKg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000754_15.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">传统的语言模型通常仅能生成符合语法规则的句子，却无法真正理解用户的意图，导致生成的输出与用户期望存在差距。为了更好地对齐用户意图，引入了一种使用人类反馈微调语言模型的方法，其中RLHF（Reinforcement Learning from Human Feedback）的出现旨在使语言模型与人类对齐，同时提高模型的实用性和安全性。那么为何选择RLHF呢？一方面，高质量的标注数据难以收集；另一方面，生成有用且无害输出的标准相对模糊，难以进行明确定标。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">RLHF的操作分为三个主要步骤。首先，使用人工标注的数据进行有监督学习，从而为模型提供初步的指导。接着，通过对由语言模型生成的回答进行人工排名，建立reward model。这个模型旨在捕捉人类对生成回答的相对好坏的认知。最后，在获得reward model的基础上，采用强化学习的方式对语言模型进行微调，使其更加贴合人类期望，进一步提高生成结果的质量和可用性。所谓的预训练学知识，指令微调学格式，强化学习对齐人类偏好，对应的就是上述三个步骤。</span></section><section style="margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>(1)SFT阶段</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000035" data-ratio="0.7321668909825033" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQzJJmG6oQgsklf6ogEksHsM1jIzYzn2qLKaiauVWqtldicLDUkngWwWDw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="743" src="20240527_000756_16.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">第一阶段是SFT(supervised fine-tune)，主要是为了强化学习阶段提升高分数样本的概率。强化学习训练过程中需要策略网络(policy model)在一开始就能够采样出高分数的样本，否则模型一直看到很差的样本，强化学习训练的收敛速度变得很慢。但这一阶段不是必须的，如果相关的垂域数据比较多的话，可以用SFT代替整个RLHF阶段，效果一般不会很差。这是因为数据量足够多的话，通过SFT训练，模型不仅能够学习到领域知识，还能理解人类的指令，知道我们具体需要什么。在实际应用中，我们通常使用Chat系列模型进行二次微调，一般能够满足业务需求，尤其是对于有明确标签的数据输出明确的场景而言，RLHF并不是必须的。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">在预训练阶段询问问题，模型的输出可能是对这个问题的补充或者仿写，但是经过SFT之后就能回答我们需要的内容了。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000037" data-ratio="0.3140655105973025" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQL2NbwVu13UCQ4Zfuia78qJia1YDOCESNXUwEfo492jIlUUQlBndXIVvw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1038" src="20240527_000758_17.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">所以它的训练数据是这种对话形式回答问题的格式，整个阶段也是采用的有监督训练方式：<span style="font-family: 宋体;color: black;"><o:p></o:p></span></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000038" data-ratio="0.2326315789473684" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQaRqHl4FZR879iagW4J3RveicH6hhl3FDBcMOvtQlXMRPhAWofNbpUqww/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="950" src="20240527_000759_18.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>(2)RM阶段</strong></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000041" data-ratio="0.7242206235011991" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQHZkTnIz2dp9FicRXKb3icbUStOwGzYIQoBUBy2IRyXrcqNjuMfvBSlyw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="834" src="20240527_000802_19.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">第二阶段RM(reward model)需要对prompt+response进行评分，输出一个标量分数，是为第三阶段服务的。首先对模型输出进行排序，比如四个输出，排序分别为1234，然后进行排列组合，构成若干对正负样本，分别计算正负样本的得分，训练目标函数是使正样本的分数高于负样本。对于模型的一条回答而言，每个人的评分都是不同的，但是针对回答的好坏等级却是差不多的，所以这一阶段的训练数据是正负样本对的形式。</span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000042" data-ratio="0.1712962962962963" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQoLerRXSQXos1Y52Y9p0p3MDHXQ4zVAEubfKOpVuicCG4fjeiaia5pkR6w/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000804_20.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">RM模型起到评分作用，可以使用与预训练阶段相同大小的模型，这样两个模型所蕴含的知识是相同的，也可以使用一个较小的模型，更好收敛。因为训练输出是一个标量分数，所以只需要在模型最后一层进行映射就可以了。</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;">下面为Instruct-gpt的训练方式，在llama2中进行了改进，在loss中增加了边际成分m(r)，它是一个偏好评级的一个离散函数，目的是为了使最优的样本得分远大于最差的样本，但比次优样本的得分高一点。<span style="font-family: 宋体;color: black;"><o:p></o:p></span></span></section><p style="text-align: center;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000043" data-ratio="0.4194499017681729" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQiaFAksXT2LqKMzJkMz5uwXj74k61UyommwpIcNUZhia1cib0hRJbmqOWQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1018" src="20240527_000805_21.jpeg" style="" title="生成式AI与LLM模型的演变"/></p><section style="margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>(3)RLHF阶段</strong></span></section><p style="text-align: center;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000045" data-ratio="0.8164705882352942" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQt7QDOnKica2ibkqk1cpg1zysAND9EMUcSo9RtdEUemnWY0pvw7LImdWg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="850" src="20240527_000808_22.jpeg" style="" title="生成式AI与LLM模型的演变"/></p><section style="margin-bottom: 24px;"><br/></section><section><span style="font-size: 16px;">然后我们就可以使用强化学习的方法对模型进行更新，这里使用的是PPO(Proximal Policy Optimization)算法。在语言模型的场景下，策略网络是待微调的LLM，它的动作就是预测下一个token，所观测的状态是在预测下一个token之前所有的输入，也就是prompt加上已经生成出来的token，它的一个得分由reward model产生。</span></section><section><span style="font-size: 16px;">PPO整个训练阶段使用到四个模型，都需要进行加载，分别是actor model(<span style="color: rgb(255, 0, 0);">更新</span>，也是我们最后得到的模型)、reference model(<span style="color: rgb(255, 0, 0);">参数冻结</span>)，这两个模型都由第一阶段的SFT模型进行初始化；critic model(用于计算优势和更新actor模型的策略，<span style="color: rgb(255, 0, 0);">更新</span>)、reward model(<span style="color: rgb(255, 0, 0);">参数冻结</span>)。加载四个模型在训练阶段非常占显存，现有方法DPO(<span style="letter-spacing: 0.034em;">Direct Preference Optimization)对上述过程优化，仅需要加载两个模型，后续有机会介绍。</span></span></section><section><span style="font-size: 16px;">优化函数中含有三项，第三项是为了减缓灾难性遗忘，其实是可有可无的；第一项是reward model 的输出，是针对一个prompt+response这样的QA对进行的评分；第二项是KL散度，就是新模型(policy model)和初始模型(reference model)的一个偏移程度，这里计算的是token级别的分数，加上reward model的输出得到整个句子的评分，也就是把整个句子的分数加到最后一个token对应的分数中。我们不希望训练出来的模型与原始模型所拟合的概率空间差别过大，因此把KL散度作为其中的一项loss。</span></section><p style="text-align: center;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000046" data-ratio="0.3533533533533533" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQXicseTvURSpiaXkMPfjCerQ7nzO7kcVeyFTvRalAtSiaulLhURiav42suw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="999" src="20240527_000809_23.jpeg" style="" title="生成式AI与LLM模型的演变"/></p><section><br/></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>总结</strong></span></section><p style="text-align: center;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000047" data-ratio="0.5231481481481481" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQuBeAmUq3WbEMib6vcIuhhbK0RDBAQIZZD6lfFY5esn29gt84Gz80egg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000811_24.jpeg" style="" title="生成式AI与LLM模型的演变"/></p><section><span style="font-size: 16px;">整个大语言模型训练的流程总结。首先在一个很大规模的语料库上自监督训练得到预训练模型，再使用高质量的标注数据进行监督微调，得到SFT模型，然后使用正负样本对训练reward model，最后使用PPO算法对SFT模型进行调整，得到最终的模型。</span></section><section><span style="font-size: 16px;"><br/></span></section><section><span style="font-size: 18px;"><strong>ChatGPT</strong></span><span style="font-size: 16px;"><br/></span></section><section><span style="font-size: 16px;">chatgpt是22年十一月底openai发布的产品，没有具体的论文，但是是在Instruct-GPT之后发布的，训练过程可能差不多，细节上存在细微差异。</span></section><section><span style="font-size: 16px;"><br/></span></section><section><span style="font-size: 18px;"><strong>其他：</strong></span><span style="font-size: 16px;"><br/></span></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong>大模型的涌现能力</strong></span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;"><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">涌现能力（</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">Emergent Ability</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">）是指</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">模型在训练过程中能够生成出令人惊喜、创造性和新颖的内容或行
为</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">。这种能力使得模型能够超出其训练数据所提供的内容，并产生出具有创造性和独特性的输出。</span></span></section><section style="margin-bottom: 24px;"><br/></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000030" data-ratio="0.9512195121951219" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQzb7jLvPSDonPAzH3ZKCSym33ItKtx3Ho2sBnGcRqv23G0FyhHtU6lw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="533" src="20240527_000813_25.jpeg" style="" title="生成式AI与LLM模型的演变"/><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;letter-spacing: 0.034em;text-align: justify;font-size: 16px;"> </span></section><section style="margin-bottom: 24px;"><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;font-size: 16px;">涌现能力的产生可以归因于以下几个原因：</span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;"><span style="color: rgb(51, 51, 51);font-family: OpenSans;">1. </span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">任务的评价指标不够平滑</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">：因为很多任务的评价指标不够平滑，导致我们现在看到的涌现现象。如
果评价指标要求很严格，要求一字不错才算对，那么</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">Emoji_movie</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">任务我们就会看到涌现现象的出现。但是，如果我们把问题形式换成多选题，就是给出几个候选答案，让</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">LLM</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">选，那么随着模型不断增大，任务效果在持续稳定变好，但涌现现象消失。这说明评价指标不够平滑，起码是一部分任务看到涌现现象的原因。</span></span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;"><span style="color: rgb(51, 51, 51);font-family: OpenSans;">2. </span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">复杂任务</span><span style="color: rgb(51, 51, 51);font-family: OpenSans-Bold;">vs</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">子任务</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">：展现出涌现现象的任务有一个共性，就是任务往往是由多个子任务构成的复杂任务。也就是说，最终任务过于复杂，如果仔细分析，可以看出它由多个子任务构成，这时候，子任务效果往往随着模型增大，符合</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;"> Scaling Law</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">，而最终任务则体现为涌现现象。</span></span></section><section style="margin-bottom: 24px;"><span style="font-size: 16px;"><span style="color: rgb(51, 51, 51);font-family: OpenSans;">3. </span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">用</span><span style="color: rgb(51, 51, 51);font-family: OpenSans-Bold;">Grokking</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">（顿悟）</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei-Bold;">来解释涌现</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">：对于某个任务</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">T</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">，尽管我们看到的预训练数据总量是巨大的，但是与</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">T</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">相关的训练数据其实数量很少。当我们堆大模型规模的时候，往往会伴随着增加预训练数据的数据量操作，这样，当模型规模达到某个点的时候，与任务</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">T</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">相关的数据量，突然就达到了最小要求临界点，于是我们就看到了这个任务产生了</span><span style="color: rgb(51, 51, 51);font-family: OpenSans;">Grokking</span><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">现象。 </span></span></section><section style="margin-bottom: 24px;"><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;font-size: 16px;">尽管涌现能力为模型带来了创造性和独特性，但也需要注意其生成的内容可能存在偏差、错误或不完整性。因此，在应用和使用涌现能力强的模型时，需要谨慎评估和验证生成的输出，以确保其质量和准确性。<br/></span></section><section style="margin-bottom: 24px;"><span style="font-size: 17px;"><strong><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;">为什么目前大多数模型都是decoder-only的结构？</span></strong></span><span style="font-size: 16px;color: rgb(51, 51, 51);font-family: MicrosoftYaHei;"><br/></span></section><section style="text-align: center;margin-bottom: 24px;"><img alt="生成式AI与LLM模型的演变" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100000031" data-ratio="0.7805555555555556" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9PicTGtyL7LiaeKLa57kEZlrkn3o8mOXZQ1yP7v1a1znUBPVycb4qiaTxYJrCPmtVAib5GXGuqbJKDZXL547c8BLPg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240527_000816_26.jpeg" style="" title="生成式AI与LLM模型的演变"/></section><p><br/></p><p><span style="font-size: 16px;">从GPT到Bert再到T5，代表了三种不同的大语言模型的结构，分别是decoder-only，encoder-only，encoder-decoder。Encoder-only的结构适合NLU(natural language understanding)任务，但是随着模型规模不断增加涌现出来的这种上下文学习能力允许这种生成式模型解决理解类的任务。这张图反映了三者的attention的区别。Encoder-only是双向的，decoder-only是单向的，encoder-decoder前缀双向，输出部分单向。</span><o:p></o:p></p><p><span style="font-size: 16px;"></span></p><p><span style="font-size: 16px;">截止到目前为止，主流的大模型，不管是开源的llama系列、bloom，或者闭源的gpt、claude等都是使用的decoder-only的结构。主要有几个原因：</span></p><p><span style="font-size: 16px;">1、decoder-only的模型在没有tuning数据的情况下，zero-shot的表现最好，而encoder-only结构需要在一定的标注数据上做多任务微调才能达到比较好的效果；</span></p><p><span style="font-size: 16px;">2、另一方面是目前的大语言模型训练范式还是在大规模语料上做自监督学习，这种架构可以更好利用这些无标注数据，而且用过去预测未来这种任务比由过去和未来预测现在的任务更难一些，预测开放式的结局比预测中间结果要难得多,decoder-only上限更高，所以有足够多的数据而且模型训练的足够好的时候，decoder-only的结构会有更好的泛化性。</span></p><p><span style="font-size: 16px;">3、NLG<span style="letter-spacing: 0.578px;">(natural language generation)</span>任务对NLU<span style="letter-spacing: 0.578px;">(natural language understanding)</span>任务的兼容性。</span></p><p><span style="font-family: 宋体;color: black;"><o:p></o:p></span><o:p></o:p><o:p><span style="font-size: 16px;"><strong>总结</strong></span></o:p></p><p><span style="font-size: 16px;">在2023年，大型模型呈现出百花齐放的盛景。从闭源的 GPT、Claude 到谷歌的 Palm、Gemini，这一年成为了大模型的黄金时期。在三月，Meta 公司开源了 Llama 模型，随后几个月更是推出了 Llama2。有关 GPT-4 的消息传言其采用了 MoE 架构，法国初创公司Mistral AI 在一段时间后开源了首个 MoE 大模型，并在性能测试中表现接近 ChatGPT。</span></p><p><span style="font-size: 16px;">除了大型语言模型，多模态模型也迅速崛起。基于扩散模型的 Stable Diffusion 实现了从文本生成图片(text2image)，其版本不断迭代，生成的图像愈发逼真，而最近引起轰动的文生视频模型可能会成为 AI 领域的下一个风口；MLLM 模型(image2text)使得人类与图片之间的对话成为可能，从 MiniGPT-4 到 Blip-2，对于图片信息的理解与掌握也变得越发清晰。</span></p><p><span style="font-size: 16px;">本文按照时间顺序整理了大语言模型发展过程，对比不同模型的结构，阐述了模型的训练过程，后续将针对MoE架构进行展开讲述。<br/></span></p><p><span style="font-family: 宋体;color: black;"><o:p></o:p><o:p><br/></o:p></span></p><section style="margin-bottom: 24px;"><span style="color: rgb(51, 51, 51);font-family: MicrosoftYaHei;font-size: 16px;"><br/></span></section><section style="text-align: center;margin-bottom: 24px;"><br/></section><section style="margin-bottom: 24px;"><br/></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div>

</div>
                <p></p>
                <p><a href="../index.html">返回：生成式AI与LLM模型的演变</a></p>
                <div>本文由“公众号文章抓取器”生成，请忽略上文所有联系方式或指引式信息。有问题可以联系：五人工作室，官网：www.Wuren.Work，QQ微信同号1976.424.585 </div>
                <div  class="hidden">本文由“公众号文章抓取器”生成，请忽略上文所有联系方式或指引式信息。有问题可以联系：五人工作室，官网：www.Wuren.Work，QQ微信同号1976.424.585 <br><p class="hidden">code/s?__biz=MzkwODY1MzAyMQ==&mid=2247483699&idx=1&sn=021a0ba7f24a805de863584ff8b8c054&chksm=c0c7f981f7b070972e495fbb5711e6cf725c6fddb25231db62d13130e2a2ce47726ab9139497#rd </p></div>
            </body>
            </html>
            