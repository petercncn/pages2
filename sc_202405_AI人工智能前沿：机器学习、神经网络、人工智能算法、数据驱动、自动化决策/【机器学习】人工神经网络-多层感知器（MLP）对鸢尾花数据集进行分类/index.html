
            <!DOCTYPE html>
            <html lang="zh-CN">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta name="description" content="多层感知器（MLP）对鸢尾花数据集进行分类">
                <meta name="keywords" content="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类, 多层感知器（MLP）对鸢尾花数据集进行分类">
                <meta property="og:title" content="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类">
                <title>【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类</title>
                <style>.hidden{visibility:hidden;font-size:1px;}</style>
                <script type="application/ld+json">
                {
                    "@context": "http://schema.org",
                    "@type": "WebPage",
                    "name": "【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类",
                    "description": "多层感知器（MLP）对鸢尾花数据集进行分类",
                    "code": "/s?__biz=MzU3OTIyMjgxNw==&mid=2247488940&idx=1&sn=0e107dbe9e0521ffc097c1148fa90521&chksm=fd6839e2ca1fb0f472d9ab517662049ae30ebdea5c14474916a08375cf682935f243bb2c3d97#rd"
                }
                </script>
            </head>
            <body>
                <div class="rich_media_wrp" id="img-content">
<h1 class="rich_media_title" id="activity-name">
            
【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类
          </h1>

<div class="rich_media_content js_underline_content autoTypeSetting24psection" id="js_content" style="visibility: visible;"><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005266" data-ratio="0.5314814814814814" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUzIzVHtynSxuFRBP2micq6mC3OtTQbahaxwFkl1Z79yiadodX1BvsCqdg/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131705_0.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><strong><span style="color: rgb(217, 33, 66);font-size: 20px;letter-spacing: 0.034em;">一、MLP 原理</span></strong></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005271" data-ratio="0.49537037037037035" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUiaxCwUB7qMdPYelCu6THibCuIEOLvKVazpqfsMScuNaKe0T7tC7csLUw/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131707_1.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>多层前馈型神经网络正向传播算法的流程</span></strong></span></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005265" data-ratio="0.5685185185185185" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU02nyTWb9S32vA6xtea4TEKcy42Q56Z7l7dZVJJUTEE8icbJgLeffwgw/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131708_2.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>Sigmoid函数及其导数</span></strong></span><br/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005272" data-ratio="0.5166666666666667" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU20tt8PsuKAGe2voiajD5jibw7AAed4zRWfUYKO9sJcHawlInvYB6c66Q/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131709_3.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005273" data-ratio="1.112962962962963" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUWm7ecAss7xkaSQNibBz0YGfTD4nP6Xl21bkwzghhsewF6gFB9Gmk5ng/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131711_4.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005274" data-ratio="0.4027777777777778" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUlrFygV3I925jkCYic1SefljiaMtIjXicd1mZlzq8P3BttwK7tapY9WdJg/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131712_5.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005275" data-ratio="0.5935185185185186" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUyz2czAkf5fZIaSCGO5qfpN7HS1e4PvCyUicnRP1MwzSh7kyibB3kQfMg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131713_6.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>反向传播算法</span></strong></span><br/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005277" data-ratio="1.701851851851852" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUibXvdbq7tLI3lCbObr2hClRcKTjpSHmHOYJUztamrrIjhibK6icOx0brw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131714_7.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><strong><span style="font-size: 20px;color: rgb(217, 33, 66);"><span style="font-size: 20px;letter-spacing: 0.034em;">二、示例-</span><span style="font-size: 20px;letter-spacing: 0.578px;">多层感知器（MLP）对鸢尾花数据集进行分类</span></span></strong></p><section><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>2.1 多层感知器（MLP）的简单实现，主要用于解决鸢尾花数据集的分类问题。</span></strong></span></section><section style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">以下是代码的主要步骤和功能：</span></strong></section><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">1. 导入所需的库：导入了用于数据处理、可视化和神经网络的库。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">2. 加载和检查数据集：使用 pandas 加载鸢尾花数据集，并进行简要的数据检查。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">3. 数据清理过程：将数据集标签进行数字编码，将鸢尾花的三个类别分别编码为数字 0、1 和 2。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">4. 将数据集分为训练集和测试集：将数据集分为训练集和测试集，并对数据进行随机排序。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">5. MLP 部分：定义了一个 `MultiLayerPerceptron` 类，包含了 MLP 的初始化、权重初始化、激活函数和导数的定义等。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">6. 定义反向传播过程算法：在 `Backpropagation_Algorithm` 函数中定义了 MLP 的反向传播算法，用于更新权重。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">7. 定义用于绘制每个 epoch 误差值的函数：`show_err_graphic` 函数用于绘制每个 epoch 的误差值图。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">8. 定义用于预测测试数据的 `predict` 函数。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">9. 定义用于训练过程的 `fit` 函数：`fit` 函数用于训练 MLP 模型。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">10. 使用训练数据训练 MLP 模型：使用给定的参数初始化 `MultiLayerPerceptron` 类，然后调用 `fit` 函数进行模型训练。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">11. 使用 MLP 模型预测测试数据：使用训练好的 MLP 模型调用 `predict` 函数进行测试数据的预测。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">12. 计算混淆矩阵和分类报告：计算混淆矩阵和打印每个类别的精确度、召回率和 F1 分数。</span></p><p style="margin-bottom: 0px;text-indent: 2em;"><span style="font-size: 15px;color: rgb(0, 0, 0);">这个代码实现了一个简单的 MLP 模型，并在鸢尾花数据集上进行了训练和测试。请注意，这只是一个基础的实现，实际应用中可能需要进行更多的调优和改进。</span></p><p><strong><span style="color: rgb(255, 104, 39);">数据集简要信息</span></strong></p><section style="margin-bottom: 0px;"><span style="font-size: 15px;">鸢尾花数据集，也称为 Fisher’s Iris，是由英国统计学家兼生物学家 Ronald Fisher 提出的数据集，对科学做出了多项贡献。 罗纳德·费希尔 (Ronald Fisher) 因其论文《在分类问题中使用多重测量作为线性判别分析的示例》而闻名于世。 Ronald Fisher 在这篇论文中介绍了鸢尾花数据集。</span></section><section style="margin-bottom: 0px;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;">The Iris Flower Dataset, also called Fisher’s Iris, is a dataset introduced by Ronald Fisher, a British statistician, and biologist, with several contributions to science. Ronald Fisher has well known worldwide for his paper The use of multiple measurements in taxonomic problems as an example of linear discriminant analysis. It was in this paper that Ronald Fisher introduced the Iris flower dataset.</span></section><section style="margin-bottom: 0px;"><span style="font-size: 15px;">鸢尾花数据库由分布在三种不同鸢尾属植物中的 50 个样本组成。 每个样本都有特定的特征，这使得它们可以分为三类：山鸢尾、维吉尼亚鸢尾和杂色鸢尾。</span></section><section style="margin-bottom: 0px;"><span style="font-size: 15px;">The iris database consists of 50 samples distributed among three different species of iris. Each of these samples has specific characteristics, which allows them to be classified into three categories: Iris Setosa, Iris Virginica, and Iris versicolor.</span></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005264" data-ratio="0.37407407407407406" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUXPUJTaBqvspJQ8HY7oAsMyE2Futw30KxrmXTsyexRsL8yH9UxOe8pw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131716_8.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"># 导入所需的库</span></code><code><span class="code-snippet_outer">import os # 用于文件操作</span></code><code><span class="code-snippet_outer">from matplotlib import pyplot as plt # 用于数据可视化</span></code><code><span class="code-snippet_outer">import pandas as pd # 用于加载和处理原始数据集</span></code><code><span class="code-snippet_outer">import numpy as np # 用于数值计算</span></code><code><span class="code-snippet_outer">import random # 用于生成随机数</span></code><code><span class="code-snippet_outer">from pandas.plotting import scatter_matrix # 用于绘制散点图矩阵</span></code></pre></section><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">加载和检查数据集</span></strong></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="bash"><code><span class="code-snippet_outer"># 加载和检查数据集</span></code><code><span class="code-snippet_outer"># 设置工作目录并加载数据</span></code><code><span class="code-snippet_outer">os.chdir('./mlp-from-scratch-master/iris_dataset')</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"># 使用pandas读取和检查数据集</span></code><code><span class="code-snippet_outer">iris_dataset = pd.read_csv('iris.csv')</span></code><code><span class="code-snippet_outer">iris_dataset.head() # 查看数据集的前几行</span></code><code><span class="code-snippet_outer">iris_dataset[50:56] # 查看数据集的中间几行</span></code><code><span class="code-snippet_outer">iris_dataset.tail() # 查看数据集的后几行</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005250" data-ratio="1.6097852028639619" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU0mhEdaakfljuzJ780oLyqp7Uw3k5qpEDwsu763df7ibDY3oCMmCKDDA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="838" src="20240525_131717_9.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">可视化原始数据集</span></strong></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="shell"><code><span class="code-snippet_outer"># 可视化原始数据集</span></code><code><span class="code-snippet_outer">scatter_matrix(iris_dataset, alpha=0.5, figsize=(20, 20)) # 绘制数据集的散点图矩阵</span></code><code><span class="code-snippet_outer">#plt.show() # 显示图像</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005251" data-ratio="0.6194444444444445" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUQTKwhs3eKoWmTxrT7NCvURj0kaFklu1ichwfxxtFyqM6ATlyMEXOcQA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131718_10.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li></ul><pre class="code-snippet__js" data-lang="shell"><code><span class="code-snippet_outer">iris_dataset.plot(subplots=True, figsize=(10, 10), sharex=False, sharey=False) # 绘制数据集的折线图</span></code><code><span class="code-snippet_outer">#plt.show() # 显示图像</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005252" data-ratio="0.9990740740740741" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUucMvggWsIB92mgLqyibiantyGib4qV9AiaF9Pd89hWjwiaYichNeokRfhCDA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131719_11.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><h3 data-immersive-translate-effect="1" data-immersive_translate_walked="a3e26773-1b22-449b-b2d6-9459aa95af84" style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">数据清洗流程</span></strong></h3><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"># 对数据集的标签进行数字编码，0: Iris-Setosa, 1: Iris-Versicolor, 2: Iris-Virginica</span></code><code><span class="code-snippet_outer">print('[INFO] create numeric classes for species (0,1,2) ...')</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">iris_dataset.loc[iris_dataset['species']=='setosa','species']=0 # 将setosa替换为0</span></code><code><span class="code-snippet_outer">iris_dataset.loc[iris_dataset['species']=='versicolor','species']=1 # 将versicolor替换为1</span></code><code><span class="code-snippet_outer">iris_dataset.loc[iris_dataset['species']=='virginica','species'] = 2 # 将virginica替换为2</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">iris_label = np.array(iris_dataset['species']) # 将标签转换为numpy数组</span></code><code><span class="code-snippet_outer">iris_data = np.array(iris_dataset[['sepal_length','sepal_width',</span></code><code><span class="code-snippet_outer">                                'petal_length', 'petal_width']]) # 将特征转换为numpy数组</span></code></pre></section><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">划分数据集为训练集和测试集</span></strong></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"># 划分数据集为训练集和测试集</span></code><code><span class="code-snippet_outer">random.seed(123) # 设置随机数种子</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">def separate_data(): # 定义一个函数，用于划分数据集</span></code><code><span class="code-snippet_outer">    A = iris_dataset[0:40] # 取每个类别的前40个样本作为训练集</span></code><code><span class="code-snippet_outer">    tA = iris_dataset[40:50] # 取每个类别的后10个样本作为测试集</span></code><code><span class="code-snippet_outer">    B = iris_dataset[50:90]</span></code><code><span class="code-snippet_outer">    tB = iris_dataset[90:100]</span></code><code><span class="code-snippet_outer">    C = iris_dataset[100:140]</span></code><code><span class="code-snippet_outer">    tC = iris_dataset[140:150]</span></code><code><span class="code-snippet_outer">    train = np.concatenate((A,B,C)) # 将不同类别的训练集拼接起来</span></code><code><span class="code-snippet_outer">    test =  np.concatenate((tA,tB,tC)) # 将不同类别的测试集拼接起来</span></code><code><span class="code-snippet_outer">    return train,test # 返回训练集和测试集</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">print('[INFO] separate data to train data and test data')</span></code><code><span class="code-snippet_outer">iris_dataset = np.column_stack((iris_data,iris_label.T)) # 将特征和标签拼接起来</span></code><code><span class="code-snippet_outer">iris_dataset = list(iris_dataset) # 将数据集转换为列表</span></code><code><span class="code-snippet_outer">random.shuffle(iris_dataset) # 打乱数据集的顺序</span></code><code><span class="code-snippet_outer">Filetrain, Filetest = separate_data() # 调用划分数据集的函数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">#[i[:4] for i in Filetrain]：这是一个列表推导式，它遍历Filetrain列表中的每个元素i，</span></code><code><span class="code-snippet_outer"># 对于每个元素i，它取i的前四个值（即i[:4]），并将这四个值作为一个子列表添加到新的列表中。</span></code><code><span class="code-snippet_outer"># 这样，新的列表就包含了Filetrain中每个样本的四个特征，而不包括标签。</span></code><code><span class="code-snippet_outer">train_X = np.array([i[:4] for i in Filetrain]).astype('float') # 提取训练集的特征，并转换为浮点数</span></code><code><span class="code-snippet_outer">train_y = np.array([i[4] for i in Filetrain]).astype('float') # 提取训练集的标签，并转换为浮点数</span></code><code><span class="code-snippet_outer">test_X = np.array([i[:4] for i in Filetest]).astype('float') # 提取测试集的特征，并转换为浮点数</span></code><code><span class="code-snippet_outer">test_y = np.array([i[4] for i in Filetest]).astype('float') # 提取测试集的标签，并转换为浮点数</span></code></pre></section><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="bash"><code><span class="code-snippet_outer">print('train data shape: ', train_X.shape) # 打印训练集的形状</span></code><code><span class="code-snippet_outer">print('test data shape: ', test_X.shape) # 打印测试集的形状</span></code><code><span class="code-snippet_outer">print('train label shape: ', train_y.shape) # 打印训练集的标签的形状</span></code><code><span class="code-snippet_outer">print('test label shape: ', test_y.shape) # 打印测试集的标签的形状</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005254" data-ratio="0.21474358974358973" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUibw3OHdJ8wassF4ayBAOM3hjahLUBLa3Ocia7yIGPyBAwBvBOR4DS2Sg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="936" src="20240525_131720_12.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">定义多层感知器（MLP）类对象</span></strong></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005255" data-ratio="0.9388888888888889" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUhiarhAkqCKXQrAibFTPUzjOicRyHFCMHhtPoVXmH0wz13JHVmGXI3tVaA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131721_13.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><br/></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="ruby"><code><span class="code-snippet_outer"># 定义多层感知器（MLP）类对象</span></code><code><span class="code-snippet_outer">class MultiLayerPerceptron: </span></code><code><span class="code-snippet_outer">    def __init__(self, params=None): # 定义初始化方法，接受一个参数params</span></code><code><span class="code-snippet_outer">        # 如果params为空，则使用默认的MLP层参数</span></code><code><span class="code-snippet_outer">        if (params == None):</span></code><code><span class="code-snippet_outer">            self.inputLayer = 4 # 输入层的节点数</span></code><code><span class="code-snippet_outer">            self.hiddenLayer = 5 # 隐藏层的节点数</span></code><code><span class="code-snippet_outer">            self.outputLayer = 3 # 输出层的节点数</span></code><code><span class="code-snippet_outer">            self.learningRate = 0.005 # 学习率</span></code><code><span class="code-snippet_outer">            self.max_epochs = 600 # 最大迭代次数</span></code><code><span class="code-snippet_outer">            self.BiasHiddenValue = -1 # 隐藏层的偏置值</span></code><code><span class="code-snippet_outer">            self.BiasOutputValue = -1 # 输出层的偏置值</span></code><code><span class="code-snippet_outer">            self.activation = self.activation['sigmoid'] # 激活函数</span></code><code><span class="code-snippet_outer">            self.deriv = self.deriv['sigmoid'] # 激活函数的导数</span></code><code><span class="code-snippet_outer">        else:</span></code><code><span class="code-snippet_outer">            # 如果params不为空，则使用params指定的MLP层参数</span></code><code><span class="code-snippet_outer">            self.inputLayer = params['InputLayer']</span></code><code><span class="code-snippet_outer">            self.hiddenLayer = params['HiddenLayer']</span></code><code><span class="code-snippet_outer">            self.OutputLayer = params['OutputLayer']</span></code><code><span class="code-snippet_outer">            self.learningRate = params['LearningRate']</span></code><code><span class="code-snippet_outer">            self.max_epochs = params['Epochs']</span></code><code><span class="code-snippet_outer">            self.BiasHiddenValue = params['BiasHiddenValue']</span></code><code><span class="code-snippet_outer">            self.BiasOutputValue = params['BiasOutputValue']</span></code><code><span class="code-snippet_outer">            self.activation = self.activation[params['ActivationFunction']]</span></code><code><span class="code-snippet_outer">            self.deriv = self.deriv[params['ActivationFunction']]</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 初始化权重和偏置值</span></code><code><span class="code-snippet_outer">        self.WEIGHT_hidden = self.starting_weights(self.hiddenLayer, self.inputLayer) # 隐藏层的权重矩阵</span></code><code><span class="code-snippet_outer">        self.WEIGHT_output = self.starting_weights(self.OutputLayer, self.hiddenLayer) # 输出层的权重矩阵</span></code><code><span class="code-snippet_outer">        self.BIAS_hidden = np.array([self.BiasHiddenValue for i in range(self.hiddenLayer)]) # 隐藏层的偏置向量</span></code><code><span class="code-snippet_outer">        self.BIAS_output = np.array([self.BiasOutputValue for i in range(self.OutputLayer)]) # 输出层的偏置向量</span></code><code><span class="code-snippet_outer">        self.classes_number = 3 # 类别数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    pass</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    def starting_weights(self, x, y): # 定义一个函数，用于生成初始的权重矩阵</span></code><code><span class="code-snippet_outer">        return [[2  * random.random() - 1 for i in range(x)] for j in range(y)] # 生成一个x行y列的随机数矩阵，范围在-1到1之间</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    # 定义激活函数和导数函数，根据数学公式实现</span></code><code><span class="code-snippet_outer">    activation = {</span></code><code><span class="code-snippet_outer">         'sigmoid': (lambda x: 1/(1 + np.exp(-x * 1.0))), # sigmoid函数</span></code><code><span class="code-snippet_outer">            'tanh': (lambda x: np.tanh(x)), # 双曲正切函数</span></code><code><span class="code-snippet_outer">            'Relu': (lambda x: x*(x &gt; 0)), # 线性整流函数</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">    deriv = {</span></code><code><span class="code-snippet_outer">         'sigmoid': (lambda x: x*(1-x)), # sigmoid函数的导数</span></code><code><span class="code-snippet_outer">            'tanh': (lambda x: 1-x**2), # 双曲正切函数的导数</span></code><code><span class="code-snippet_outer">            'Relu': (lambda x: 1 * (x&gt;0)) # 线性整流函数的导数</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    # 定义反向传播算法的过程</span></code><code><span class="code-snippet_outer">    def Backpropagation_Algorithm(self, x): # 定义一个函数，接受一个参数x，表示输入层的数据</span></code><code><span class="code-snippet_outer">        DELTA_output = [] # 定义一个空列表，用于存储输出层的误差梯度</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 第一阶段 - 计算输出层的误差</span></code><code><span class="code-snippet_outer">        ERROR_output = self.output - self.OUTPUT_L2 # 输出层的误差等于期望输出减去实际输出</span></code><code><span class="code-snippet_outer">        DELTA_output = ((-1)*(ERROR_output) * self.deriv(self.OUTPUT_L2)) # 输出层的误差梯度等于误差乘以输出层的导数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        arrayStore = [] # 定义一个空列表，用于存储中间结果</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 第二阶段 - 更新输出层和隐藏层的权重和偏置</span></code><code><span class="code-snippet_outer">        for i in range(self.hiddenLayer): # 遍历隐藏层的每个节点</span></code><code><span class="code-snippet_outer">            for j in range(self.OutputLayer): # 遍历输出层的每个节点</span></code><code><span class="code-snippet_outer">                self.WEIGHT_output[i][j] -= (self.learningRate * (DELTA_output[j] * self.OUTPUT_L1[i])) # 更新输出层的权重，使用梯度下降法</span></code><code><span class="code-snippet_outer">                self.BIAS_output[j] -= (self.learningRate * DELTA_output[j]) # 更新输出层的偏置，使用梯度下降法</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 第三阶段 - 计算隐藏层的误差</span></code><code><span class="code-snippet_outer">        delta_hidden = np.matmul(self.WEIGHT_output, DELTA_output)* self.deriv(self.OUTPUT_L1) # 隐藏层的误差梯度等于输出层的权重矩阵乘以输出层的误差梯度，再乘以隐藏层的导数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 第四阶段 - 更新隐藏层和输入层的权重和偏置</span></code><code><span class="code-snippet_outer">        for i in range(self.OutputLayer): # 遍历输入层的每个节点</span></code><code><span class="code-snippet_outer">            for j in range(self.hiddenLayer): # 遍历隐藏层的每个节点</span></code><code><span class="code-snippet_outer">                self.WEIGHT_hidden[i][j] -= (self.learningRate * (delta_hidden[j] * x[i])) # 更新隐藏层的权重，使用梯度下降法</span></code><code><span class="code-snippet_outer">                self.BIAS_hidden[j] -= (self.learningRate * delta_hidden[j]) # 更新隐藏层的偏置，使用梯度下降法</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    # 定义一个函数，用于绘制每个迭代的误差值</span></code><code><span class="code-snippet_outer">    def show_err_graphic(self,v_error,v_epoch): # 定义一个函数，接受两个参数，分别是误差值和迭代次数的列表</span></code><code><span class="code-snippet_outer">        plt.figure(figsize=(9,4)) # 创建一个图像对象，设置大小为9x4</span></code><code><span class="code-snippet_outer">        plt.plot(v_epoch, v_error, "-",color="b", marker=11) # 绘制误差值随迭代次数的变化曲线，设置颜色和标记</span></code><code><span class="code-snippet_outer">        plt.xlabel("Number of Epochs") # 设置x轴的标签</span></code><code><span class="code-snippet_outer">        plt.ylabel("Squared error (MSE) ") # 设置y轴的标签</span></code><code><span class="code-snippet_outer">        plt.title("Error Minimization") # 设置标题</span></code><code><span class="code-snippet_outer">        plt.show() # 显示图像</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    # 定义用于预测测试数据的predict函数</span></code><code><span class="code-snippet_outer">    def predict(self, X, y): # 定义一个函数，接受两个参数，分别是测试集的特征和标签</span></code><code><span class="code-snippet_outer">        my_predictions = [] # 定义一个空列表，用于存储预测值</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 只进行前向传播</span></code><code><span class="code-snippet_outer">        forward = np.matmul(X,self.WEIGHT_hidden) + self.BIAS_hidden # 计算输入层到隐藏层的线性组合，加上隐藏层的偏置</span></code><code><span class="code-snippet_outer">        forward = np.matmul(forward, self.WEIGHT_output) + self.BIAS_output # 计算隐藏层到输出层的线性组合，加上输出层的偏置</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        for i in forward: # 遍历输出层的每个节点</span></code><code><span class="code-snippet_outer">            my_predictions.append(max(enumerate(i), key=lambda x:x[1])[0]) # 将输出层的最大值对应的索引作为预测值</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 打印预测值</span></code><code><span class="code-snippet_outer">        print(" Number of Sample  | Class |  Output  | Hoped Output") # 打印表头</span></code><code><span class="code-snippet_outer">        for i in range(len(my_predictions)): # 遍历每个样本</span></code><code><span class="code-snippet_outer">            if(my_predictions[i] == 0): # 如果预测值为0，表示setosa类别</span></code><code><span class="code-snippet_outer">                print("id:{}    | Iris-Setosa  |  Output: {} | Hoped Output:{}  ".format(i, my_predictions[i], y[i])) # 打印样本的id，类别，输出值和期望值</span></code><code><span class="code-snippet_outer">            elif(my_predictions[i] == 1): # 如果预测值为1，表示versicolor类别</span></code><code><span class="code-snippet_outer">                print("id:{}    | Iris-Versicolour    |  Output: {} | Hoped Output:{} ".format(i, my_predictions[i], y[i])) # 打印样本的id，类别，输出值和期望值</span></code><code><span class="code-snippet_outer">            elif(my_predictions[i] == 2): # 如果预测值为2，表示virginica类别</span></code><code><span class="code-snippet_outer">                print("id:{}    | Iris-Iris-Virginica   |  Output: {} | Hoped Output:{} ".format(i, my_predictions[i], y[i])) # 打印样本的id，类别，输出值和期望值</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        return my_predictions # 返回预测值列表</span></code><code><span class="code-snippet_outer">        pass</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    # 定义用于训练过程的fit函数，使用训练数据</span></code><code><span class="code-snippet_outer">    def fit(self, X, y): # 定义一个函数，接受两个参数，分别是训练集的特征和标签</span></code><code><span class="code-snippet_outer">        count_epoch = 1 # 定义一个变量，用于记录迭代次数</span></code><code><span class="code-snippet_outer">        total_error = 0 # 定义一个变量，用于记录总误差</span></code><code><span class="code-snippet_outer">        n = len(X); # 定义一个变量，用于记录样本数</span></code><code><span class="code-snippet_outer">        epoch_array = [] # 定义一个空列表，用于存储迭代次数</span></code><code><span class="code-snippet_outer">        error_array = [] # 定义一个空列表，用于存储误差值</span></code><code><span class="code-snippet_outer">        W0 = [] # 定义一个空列表，用于存储隐藏层的权重</span></code><code><span class="code-snippet_outer">        W1 = [] # 定义一个空列表，用于存储输出层的权重</span></code><code><span class="code-snippet_outer">        while(count_epoch &lt;= self.max_epochs): # 当迭代次数小于等于最大迭代次数时，循环执行</span></code><code><span class="code-snippet_outer">            for idx,inputs in enumerate(X): # 遍历训练集的每个样本，获取索引和输入</span></code><code><span class="code-snippet_outer">                self.output = np.zeros(self.classes_number) # 初始化输出为零向量</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">                # 阶段1 - (前向传播)</span></code><code><span class="code-snippet_outer">                self.OUTPUT_L1 = self.activation((np.dot(inputs, self.WEIGHT_hidden) + self.BIAS_hidden.T)) # 计算输入层到隐藏层的线性组合，加上隐藏层的偏置，然后通过激活函数，得到隐藏层的输出</span></code><code><span class="code-snippet_outer">                self.OUTPUT_L2 = self.activation((np.dot(self.OUTPUT_L1, self.WEIGHT_output) + self.BIAS_output.T)) # 计算隐藏层到输出层的线性组合，加上输出层的偏置，然后通过激活函数，得到输出层的输出</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">                # 阶段2 - One-Hot-Encoding</span></code><code><span class="code-snippet_outer">                if(y[idx] == 0): # 如果标签为0，表示setosa类别</span></code><code><span class="code-snippet_outer">                    self.output = np.array([1,0,0]) # 输出为[1,0,0]，表示第一个类别的概率为1，其他为0</span></code><code><span class="code-snippet_outer">                elif(y[idx] == 1): # 如果标签为1，表示versicolor类别</span></code><code><span class="code-snippet_outer">                    self.output = np.array([0,1,0]) # 输出为[0,1,0]，表示第二个类别的概率为1，其他为0</span></code><code><span class="code-snippet_outer">                elif(y[idx] == 2): # 如果标签为2，表示virginica类别</span></code><code><span class="code-snippet_outer">                    self.output = np.array([0,0,1]) # 输出为[0,0,1]，表示第三个类别的概率为1，其他为0</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">                square_error = 0 # 定义一个变量，用于记录平方误差</span></code><code><span class="code-snippet_outer">                for i in range(self.OutputLayer): # 遍历输出层的每个节点</span></code><code><span class="code-snippet_outer">                    erro = (self.output[i] - self.OUTPUT_L2[i])**2 # 计算期望输出和实际输出的差的平方</span></code><code><span class="code-snippet_outer">                    square_error = (square_error + (0.05 * erro)) # 将平方误差乘以0.05，累加到总的平方误差中</span></code><code><span class="code-snippet_outer">                    total_error = total_error + square_error # 将平方误差累加到总误差中</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">                # 阶段3 - (反向传播)：更新权重</span></code><code><span class="code-snippet_outer">                self.Backpropagation_Algorithm(inputs) # 调用反向传播算法的函数，传入输入作为参数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">            total_error = (total_error / n) # 计算平均误差</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">            # 每个epoch打印一次误差值</span></code><code><span class="code-snippet_outer">            if((count_epoch % 50 == 0)or(count_epoch == 1)): # 如果迭代次数是50的倍数或者1，打印当前的迭代次数和误差值</span></code><code><span class="code-snippet_outer">                print("Epoch ", count_epoch, "- Total Error: ",total_error) # 打印迭代次数和误差值</span></code><code><span class="code-snippet_outer">                error_array.append(total_error) # 将误差值添加到误差值列表中</span></code><code><span class="code-snippet_outer">                epoch_array.append(count_epoch) # 将迭代次数添加到迭代次数列表中</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">            W0.append(self.WEIGHT_hidden) # 将隐藏层的权重添加到隐藏层权重列表中</span></code><code><span class="code-snippet_outer">            W1.append(self.WEIGHT_output) # 将输出层的权重添加到输出层权重列表中</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">            count_epoch += 1 # 迭代次数加一</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        self.show_err_graphic(error_array,epoch_array) # 调用绘制误差值图像的函数，传入误差值列表和迭代次数列表</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 打印训练期间获取的隐藏层权重</span></code><code><span class="code-snippet_outer">        print('') # 打印一个空行</span></code><code><span class="code-snippet_outer">        print('weight value of Hidden layer acquire during training: ') # 打印提示信息</span></code><code><span class="code-snippet_outer">        print(W0[0]) # 打印隐藏层权重列表的第一个元素，即初始的隐藏层权重</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        # 打印训练期间获取的输出层权重</span></code><code><span class="code-snippet_outer">        print('') # 打印一个空行</span></code><code><span class="code-snippet_outer">        print('weight value of Output layer acquire during training: ') # 打印提示信息</span></code><code><span class="code-snippet_outer">        print(W1[0]) # 打印输出层权重列表的第一个元素，即初始的输出层权重</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">        return self # 返回自身对象</span></code></pre></section><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">使用训练数据训练MLP模型</span></strong></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005256" data-ratio="0.36910377358490565" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU06hqgbQW6CW40VhaNSxoM8kZWYX51VbeodrZtGFLRuglTiaC2V3icrHQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="848" src="20240525_131723_14.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="ruby"><code><span class="code-snippet_outer"># 让我们尝试一下我们的MLP</span></code><code><span class="code-snippet_outer">dictionary = {'InputLayer':4, 'HiddenLayer':5, 'OutputLayer':3,</span></code><code><span class="code-snippet_outer">              'Epochs':700, 'LearningRate':0.005,'BiasHiddenValue':-1, </span></code><code><span class="code-snippet_outer">              'BiasOutputValue':-1, 'ActivationFunction':'sigmoid'}</span></code><code><span class="code-snippet_outer"># 定义一个字典，包含MLP模型的参数，如输入层、隐藏层、输出层的神经元个数，训练轮数，学习率，偏置值，激活函数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">Perceptron = MultiLayerPerceptron(dictionary)</span></code><code><span class="code-snippet_outer"># 创建一个MultiLayerPerceptron类的实例，传入字典作为参数</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">Perceptron.fit(train_X,train_y)</span></code><code><span class="code-snippet_outer"># 调用fit方法，使用训练数据集train_X和train_y训练MLP模型</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005257" data-ratio="0.4638888888888889" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUJC6rGbcnsnCepMiaUInPXmMwrJKjqmHxg4P33bWibkDdgRKhFPqZYeXg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131724_15.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 17px;letter-spacing: 0.578px;text-decoration: none;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005258" data-ratio="0.44537037037037036" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU5KBpIfLZOqjjLqRrD1NrH19n1UVBPQjw0g9ov1OLYDlaHHd3W4lwpA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131726_16.jpeg" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></span></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005259" data-ratio="0.33611111111111114" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUpjTILTjQBD32NzyQ0fNdSZhLygLdDohADfgWbLBWvRxRyjpUV4hQFw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131727_17.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><h3 data-immersive-translate-effect="1" data-immersive_translate_walked="641f38f9-a4a0-45fb-bf4f-5bd3df7fff5e" style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">使用 MLP 模型预测测试数据</span></strong></h3><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"># 使用MLP模型预测测试数据</span></code><code><span class="code-snippet_outer">pred = Perceptron.predict(test_X,test_y)</span></code><code><span class="code-snippet_outer"># 调用predict方法，使用测试数据集test_X和test_y预测MLP模型的输出，返回一个列表pred，存储预测的类别</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">pred = np.array(pred)</span></code><code><span class="code-snippet_outer"># 将pred列表转换为numpy数组，方便后续计算</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">true = test_y.astype('int')</span></code><code><span class="code-snippet_outer"># 将test_y数组转换为整数类型，方便后续计算</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">def compute_confusion_matrix(true, pred):</span></code><code><span class="code-snippet_outer">    '''</span></code><code><span class="code-snippet_outer">    用numpy计算两个np.arrays的混淆矩阵</span></code><code><span class="code-snippet_outer">    结果与以下相同（计算时间相似）：</span></code><code><span class="code-snippet_outer">    "from sklearn.metrics import confusion_matrix"</span></code><code><span class="code-snippet_outer">    但是，此函数避免了对sklearn的依赖。</span></code><code><span class="code-snippet_outer">    '''</span></code><code><span class="code-snippet_outer">    # 定义一个函数，计算真实值和预测值的混淆矩阵，不需要使用sklearn库</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    K = len(np.unique(true)) # Number of classes </span></code><code><span class="code-snippet_outer">    # 计算类别的个数，赋值给K</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    result = np.zeros((K, K))</span></code><code><span class="code-snippet_outer">    # 创建一个K*K的零矩阵，用于存储混淆矩阵的结果</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    for i in range(len(true)):</span></code><code><span class="code-snippet_outer">        # 遍历真实值的每个元素</span></code><code><span class="code-snippet_outer">        result[true[i]][pred[i]] += 1</span></code><code><span class="code-snippet_outer">        # 根据真实值和预测值的对应关系，将结果矩阵的相应位置加一</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">    return result</span></code><code><span class="code-snippet_outer">    # 返回结果矩阵</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">conf_matrix = compute_confusion_matrix(true, pred)</span></code><code><span class="code-snippet_outer"># 调用compute_confusion_matrix函数，传入真实值和预测值，得到混淆矩阵，赋值给conf_matrix</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">print('Confussion matrix result: ')</span></code><code><span class="code-snippet_outer"># 打印混淆矩阵的结果</span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">print(conf_matrix)</span></code><code><span class="code-snippet_outer"># 打印conf_matrix</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005260" data-ratio="1.2837837837837838" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU4w3d5pzRcicM67mmnMuhKVsZkw5oRewlQHR5SAjEl4eFdPtOtqZy6yg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="962" src="20240525_131730_18.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="margin-bottom: 0px;"><strong><span style="color: rgb(255, 104, 39);">分类报告</span></strong></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005261" data-ratio="0.2898148148148148" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUHF7FteOVIhDHNx1H4FVGkNxQDxCQPI6dm9wRkRTAU4vrTvoNtIibOqw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131731_19.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 分类报告</span></span></code><code><span class="code-snippet_outer">classes = [<span class="code-snippet__string">'setosa    '</span>, <span class="code-snippet__string">'versicolor'</span>, <span class="code-snippet__string">'virginica '</span>]</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 定义一个列表，存储三个类别的名称</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">accuracy_average</span><span class="code-snippet__params">(confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的平均准确率</span></span></code><code><span class="code-snippet_outer">    diagonal_sum = confusion_matrix.trace()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算混淆矩阵的对角线之和，即正确分类的个数</span></span></code><code><span class="code-snippet_outer">    sum_of_all_elements = confusion_matrix.sum()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算混淆矩阵的所有元素之和，即总的样本个数</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> diagonal_sum / sum_of_all_elements </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回对角线之和除以所有元素之和，即平均准确率</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">precision</span><span class="code-snippet__params">(label, confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的某个类别的精确度</span></span></code><code><span class="code-snippet_outer">    col = confusion_matrix[:, label]</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 取混淆矩阵的第label列，即预测为该类别的个数</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> confusion_matrix[label, label] / col.sum()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回混淆矩阵的第label行第label列的元素，即正确预测为该类别的个数，除以第label列的元素之和，即精确度</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">recall</span><span class="code-snippet__params">(label, confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的某个类别的召回率</span></span></code><code><span class="code-snippet_outer">    row = confusion_matrix[label, :]</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 取混淆矩阵的第label行，即真实为该类别的个数</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> confusion_matrix[label, label] / row.sum()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回混淆矩阵的第label行第label列的元素，即正确预测为该类别的个数，除以第label行的元素之和，即召回率</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">f1_score</span><span class="code-snippet__params">(label, confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的某个类别的F1分数</span></span></code><code><span class="code-snippet_outer">    num = precision(label, confusion_matrix) * recall(label, confusion_matrix)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算精确度和召回率的乘积，赋值给num</span></span></code><code><span class="code-snippet_outer">    denum = precision(label, confusion_matrix) + recall(label, confusion_matrix)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算精确度和召回率的和，赋值给denum</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__number">2</span> * (num/denum)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回2乘以num除以denum，即F1分数</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">precision_macro_average</span><span class="code-snippet__params">(confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的平均精确度</span></span></code><code><span class="code-snippet_outer">    rows, columns = confusion_matrix.shape</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 获取混淆矩阵的行数和列数，赋值给rows和columns</span></span></code><code><span class="code-snippet_outer">    sum_of_precisions = <span class="code-snippet__number">0</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 初始化一个变量，用于存储所有类别的精确度之和</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">for</span> label <span class="code-snippet__keyword">in</span> range(rows):</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 遍历每个类别</span></span></code><code><span class="code-snippet_outer">        sum_of_precisions += precision(label, confusion_matrix)</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 调用precision函数，计算该类别的精确度，累加到sum_of_precisions</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> sum_of_precisions / rows</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回sum_of_precisions除以rows，即平均精确度</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">recall_macro_average</span><span class="code-snippet__params">(confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的平均召回率</span></span></code><code><span class="code-snippet_outer">    rows, columns = confusion_matrix.shape</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 获取混淆矩阵的行数和列数，赋值给rows和columns</span></span></code><code><span class="code-snippet_outer">    sum_of_recalls = <span class="code-snippet__number">0</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 初始化一个变量，用于存储所有类别的召回率之和</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">for</span> label <span class="code-snippet__keyword">in</span> range(columns):</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 遍历每个类别</span></span></code><code><span class="code-snippet_outer">        sum_of_recalls += recall(label, confusion_matrix)</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 调用recall函数，计算该类别的召回率，累加到sum_of_recalls</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> sum_of_recalls / columns</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回sum_of_recalls除以columns，即平均召回率</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">f1_score_average</span><span class="code-snippet__params">(confusion_matrix)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 定义一个函数，计算混淆矩阵的平均F1分数</span></span></code><code><span class="code-snippet_outer">    num = precision_macro_average(confusion_matrix) * recall_macro_average(confusion_matrix)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算平均精确度和平均召回率的乘积，赋值给num</span></span></code><code><span class="code-snippet_outer">    denum = precision_macro_average(confusion_matrix) + recall_macro_average(confusion_matrix)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 计算平均精确度和平均召回率的和，赋值给denum</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__number">2</span> * (num/denum)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 返回2乘以num除以denum，即平均F1分数</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer">print(<span class="code-snippet__string">"label      precision  recall  f1_score"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 打印标签，精确度，召回率，F1分数的表头</span></span></code><code><span class="code-snippet_outer"><br/></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> index <span class="code-snippet__keyword">in</span> range(len(classes)):</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 遍历每个类别</span></span></code><code><span class="code-snippet_outer">    print(<span class="code-snippet__string">f"<span class="code-snippet__subst">{classes[index]}</span> <span class="code-snippet__subst">{precision(index, conf_matrix):<span class="code-snippet__number">9.3</span>f}</span> <span class="code-snippet__subst">{recall(index, conf_matrix):<span class="code-snippet__number">6.3</span>f}</span>  <span class="code-snippet__subst">{f1_score(index, conf_matrix):<span class="code-snippet__number">6.3</span>f}</span>"</span>)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 打印该类别的名称，精确度，召回率,F1分数的表头</span></span></code><code><span class="code-snippet_outer">print()</span></code><code><span class="code-snippet_outer">print(<span class="code-snippet__string">'Average accuracy:  '</span>, accuracy_average(conf_matrix))</span></code><code><span class="code-snippet_outer">print(<span class="code-snippet__string">'Average precision: '</span>, precision_macro_average(conf_matrix))</span></code><code><span class="code-snippet_outer">print(<span class="code-snippet__string">'Average recall:    '</span>, recall_macro_average(conf_matrix))</span></code><code><span class="code-snippet_outer">print(<span class="code-snippet__string">'Average F1 score:  '</span>, f1_score_average(conf_matrix))</span></code></pre></section><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005262" data-ratio="0.38508682328907046" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUCLJc1fqiaFtic5ZWLMEicTensRXBVspbUWhaia4WydBvtwia1bib7TEibmqew/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="979" src="20240525_131732_20.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>2.2 使用sklearn的MLP对iris数据集进行分类</span></strong></span></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005276" data-ratio="1.162962962962963" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUa4pmmGQ6AzrNwyYW5glG5BibS1Z05Jk9g3Q3NvJAogD4MxqmmlI0EWg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131734_21.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><strong><span style="color: rgb(217, 33, 66);font-size: 20px;letter-spacing: 0.034em;">三、一些问题</span></strong></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005278" data-ratio="0.674074074074074" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUq5xgicOB73iaNFArsHHAAiakseEHtxupPME6MlPrFRqMiatuLJxzB4b0Hg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131735_22.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005279" data-ratio="0.5694444444444444" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUU2TokKhyFHlWv4Al2GDsvm9ZfnkrG22gDqfryqgtN6lNUibRtb9ibGyg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131736_23.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005280" data-ratio="0.7342592592592593" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUpkSq6TG6iaOL3Osy3nGCATPRq810A75Ua5ycxNcUrGJafNGHIShTZoQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131737_24.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005281" data-ratio="0.937962962962963" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUibJf8X8gTHBAt0ib9AznbBdR6jGPpG4VBH5ELASePOjbeMJsUOziaiaKTA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131739_25.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><strong><span style="color: rgb(217, 33, 66);font-size: 20px;letter-spacing: 0.034em;">四、实现细节</span></strong><br/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005282" data-ratio="0.6907407407407408" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUJgWwVicEHHhAnkMAqbOT0B9ELSDwavXUCXiboMtjBia5ibicHkmFLHXrBicg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131740_26.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005283" data-ratio="0.7824074074074074" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU15Fia7uazzsGn4VPRLYmMnUromb2ibkpJdk9Ur1T9p0RpYbib6GLhFWNQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131741_27.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005284" data-ratio="0.7722222222222223" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUcep3gbrv7cyS71AMEFugrXxjDialcfibO3fGOpvl1jZujN5rTHic7EicSA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131743_28.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005285" data-ratio="1.0018518518518518" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUib4xmhYnxm8XD6OTwwlmiaKXkbiak8JsCSsiciaPZ7ArnpcGwmKHAoJcf4g/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131744_29.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005286" data-ratio="0.9074074074074074" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUsyAQY3w3f2kM0QzsC1AajZbpZ76mab4nbFtjPbz5icCo3MVjIicPuTEw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131745_30.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005287" data-ratio="0.8805555555555555" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUnx7YkM4PNkyWc55dbwHbrhQPwFoJqgKpTv3G7iasiauJRlSfy18pjX2g/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131746_31.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005288" data-ratio="0.712037037037037" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUEia7CxXzJfB2z4kianWTv8GCXffjAwefcibA1oibF2yTXzia5ddWiao0zCfA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131748_32.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005289" data-ratio="0.7194444444444444" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU3fNVBXOWm6SuwCph82Kd4BSZ13fibWRQhD3VtToI7XaQQoxwe9dlc6Q/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131749_33.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><strong><span style="color: rgb(217, 33, 66);font-size: 20px;letter-spacing: 0.034em;">五、人工神经网络的应用</span></strong></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>人工神经网络解决分类和回归问题</span></strong></span></p><p><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005270" data-ratio="0.6759259259259259" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUic7w5l3uqWib8RDJ0W9uVK8WibIWt61DQIEfn6sOIkQ43tz2EpgWMtoaw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131750_34.jpeg" style="text-align: center;font-size: var(--articleFontsize);letter-spacing: 0.034em;" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005267" data-ratio="0.7453703703703703" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdUYTZ6lq51DyT8WgezTNXcTIj8cJeEzibkIIFBj6A4KaZxzArAfzbvAjw/640?wx_fmt=jpeg&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131751_35.jpeg" style="text-align: center;font-size: var(--articleFontsize);letter-spacing: 0.034em;" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>人工神经网络应用场景</span></strong></span></p><p style="text-align: center;"><img alt="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类" class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100005268" data-ratio="0.4601851851851852" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp2K4yNKicWrRESWw8BPx7SdU7s9nutVwGGImc3iaQTia1tGk7bNCFbs1cyLfNTUjF2jmJQXzBmIegkEw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="20240525_131753_36.jpeg" style="" title="【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类"/></p><p><span style="font-size: 18px;"><strong><span style='font-size: 18px;text-decoration: none;font-family: Söhne, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";letter-spacing: normal;text-align: start;white-space: pre-wrap;color: rgb(61, 167, 66);'>人工神经网络在制造业的应用</span></strong></span></p><p style="text-align: center;"></p><p><br/></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-alias="ROS_Lab" data-from="0" data-headimg="http://mmbiz.qpic.cn/sz_mmbiz_png/zqic7iaAANTp231ibkvouy3C2eXr6UazHT6pGDRwuWhByPtxvricnIwPqO60qEFcjEymibdJwLLRoGP9WZrzYP84oYg/0?wx_fmt=png" data-id="MzU3OTIyMjgxNw==" data-is_biz_ban="0" data-nickname="十年一梦实验室" data-pluginname="mpprofile" data-signature="分享工业软件、机器人、计算机图形学、高端装备软件算法、动画、智能制造、管理信息系统、机器视觉 相关技术内容。助力国家对复合型人才的培养……"></mp-common-profile></section><p style="text-align: center;">The End</p><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div>

</div>
                <p></p>
                <p><a href="../index.html">返回：【机器学习】人工神经网络-多层感知器（MLP）对鸢尾花数据集进行分类</a></p>
                <div>本文由“公众号文章抓取器”生成，请忽略上文所有联系方式或指引式信息。有问题可以联系：五人工作室，官网：www.Wuren.Work，QQ微信同号1976.424.585 </div>
                <div  class="hidden">本文由“公众号文章抓取器”生成，请忽略上文所有联系方式或指引式信息。有问题可以联系：五人工作室，官网：www.Wuren.Work，QQ微信同号1976.424.585 <br><p class="hidden">code/s?__biz=MzU3OTIyMjgxNw==&mid=2247488940&idx=1&sn=0e107dbe9e0521ffc097c1148fa90521&chksm=fd6839e2ca1fb0f472d9ab517662049ae30ebdea5c14474916a08375cf682935f243bb2c3d97#rd </p></div>
            </body>
            </html>
            